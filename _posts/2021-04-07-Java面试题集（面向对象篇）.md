# Java 面试题集一 —— 面向对象篇

**1、阐述一下几种编程模式以及，以及各自的优缺点**

常见的编程模式有，面向过程编程、面向对象编程；

- **面向过程编程：**是具体化的流程化的，解决一个问题需要一步一步分析，一步一步的实现；

​		优点：性能高于面向对象，因为类的实例化，开销较大，比较耗费资源，单片机，嵌入式开发、linux一般采用面向过程开发；

​		缺点：没有面向对象编程那样，易于维护，拓展性不强；

- **面向对象编程：是**模型化、抽象化的过程，只需要抽象出一个类，这就是一个封闭的盒子，在这个盒子里，你有解决问题所需要的数据以及方法，需要什么功能直接使用就好，不必要一步一步的实现；

​		优点：易于维护，拓展，复用，由于面向对象具有封装，继承，多态等特性，可以设计出低耦合，高复用的系统。

​		缺点：性能开销过大；



**2、面向对象的四大特征**

- 抽象

抽象就是将某一类对象的共同特征归纳总结、提炼出来，主要是数据抽象和行为抽象，只关注对象有哪些属性行为；

- 封装

封装是将一个对象的树形进行私有化，限制其访问范围，同时提供一些可以让外界访问属性的方法，当然也可以不提供；

- 继承

继承是使用 已经存在的类的基础之上，创建新类的技术，新类可以服用父类的相关属性和方法，也可以在父类已有的属性方法上进行拓展，通过继承，我们可以很方便的复用以前的代码；

- 多态

所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

在Java中有两种形式可以实现多态：**继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。**

多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。



**3、 多态的实现**

Java实现多态有三个必要条件：继承、重写、向上转型。

继承：在多态中必须存在有继承关系的子类和父类。

重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。

向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。

只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。

对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。



**4、重写&&重载**

- 重写 存在于继承关系中，子父类中，子类重写父类的方法，达到，对功能拓展的;子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以**在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下，** 对方法体进行修改或重写，这就是重写。但要注意**子类函数的访问修饰权限不能少于父类的**
- 重载：存在于同意类中，对同一方法的不同实现，同名的方法如果有不同的参数列表（**参数类型不同、参数个数不同甚至是参数顺序不同**）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但**不能通过返回类型是否相同来判断重载**。 



**5、对 java.lang.Object 类的理解；**

Object类是所有类型的父类，在生命一个类是，没有指明其父类是什么，则其默认的负累为Object类，Object，没有属性，只有方法；

其常见的方法有，**equals(),toString(),getClass(),hashCode(),clone(),finalize(), wait(),notify(),notifyAll();**

- equals() ,是Object 类中的一个方法，只能应用于引用类型的数据之间进行比较，其默认定义为:

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

默认实现比较的是两个对象指向的**地址值是否相同(此时与== 的用法相同)**，一般在开发中都需要重写，比较两个类的相关属性是否相等；

- hashCode()

散列码(hashCode):是由对象导出的一个整数值.散列码是没有规律的，由于hashCode()定义在Object类中,因此每个对象都有一个默认的散列码,其值为对象的存储地址

- toString()

```java
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

默认返回的是 类名+地址值，一般要重写,返回对象的实体内容； String， File ,Date 类都重写了 toString() 方法；

- getClass()  返回对象信息的类对象；

```java
public final native Class<?> getClass();
```

- clone() 

clone 顾名思义，就是复制，在Java语言中， clone方法被对象调用，所以会复制对象。所谓的复制对象，首先要分配一个和源对象同样大小的空间，在这个空间中创建一个新的对象。那么在java语言中；

- finalize() 是java gc 中，最后调用垃圾处理函数的；
- wait() ,notify(),notifyAll() 是和线程操作相关的方法；



**6、为什么重写equals() 方法就一定要重写 hashCode() 方法：**

在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。　从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。
如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。
如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么两个对象不一定必须产生不同的整数结果。　但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。



**7、创建对象的方式，有哪几种？clone 和 new 着两种创建对象的方式的区别？**

-  使用new操作符

-  调用Class或java.lang.reflect.Constructor对象的newInstance()方法

- 调用任何对象的clone()方法

- 通过java.io.ObjectInputStream类的getObject()

那么这两种方式有什么相同和不同呢？

​	 **new操**作符的本意是分配内存。程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。

​	**而clone**在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。



**8、 包装类的引入，为什么需要包装类，自动装箱、自动拆箱？**

包装类是指，对java 8中基本数据类型的包装，为了使基本数据类型具有类的特性，从而引入包装类；

具体如下： byte-Byte、short-Short、int-Integer、long-Long、float-Float、double-Double、boolean-Boolean、char-Character

基本数据类型转换为包装类，称为装箱；

包装类转换为基本数据类型，称为拆箱；



**9、static 关键字**

Static 关键字，静态的，可以用来修饰， **属性、方法、代码块、内部类**

- 修饰属性  称为静态变量（类变量）

同一类实例化出来的对象，拥有各自的一套非静态变量，所有对象共享一套静态变量；

 静态变量的访问可以通过  **类名.静态变量**  也可以通过 **实例名.静态变量** 这样的方式访问；

- 修饰方法 静态方法

静态方法，可以通过 **类.静态方法** 调用； 静态方法中只能调用静态的方法和属性，非静态方法既可以调用非警惕啊方法的属性和方法，也可以调用静态方法的属性和方法；



**那些方法和属性应该声明为静态？**

- 属性被多个对象所共享，不回岁对象的不同而不同的；
- 类中的常量，一般声明为静态的；
- 操作静态属性的方法一般声明为静态的；
- 工具类中的方法一般声明为静态的，如 Math,Arrays，Collections;



**10、抽象类  &&  接口**

- **抽象类 ： 用abstract 修饰的类称为抽象类；**

抽象类存在的意义，如果一个类，存在抽象方法，这个类就是抽象类（但是抽象类不一定有抽象方法），抽象类不能被实例化；

抽象类中可以存在普通的成员变量和方法；

**抽象类和普通类的区别：**

（1）抽象类不能直接用于类对象实例化；

（2）抽象方法，必须为publi 或者是portected,默认缺省为public;（因为抽象类必须由其子类进行实例化，才能发挥它的作用，若是抽象方法被声明成 private ，子类不能继承，抽象类，就没有存在的意义了）；

（3）如果一个类继承了抽象类，那么这个类必须实现父类的抽象方法；若没有实现，则子类也是抽象类；

- **使用interface 声明的称为接口；**

（1）在接口中，只能对方法进行声明，但是不能对方法进行实现；但是JDK 9 之后，接口中方法可以添加默认实现；

（2）接口中，不能定义构造函数，意味着，接口不可以实例化；

（3）在开发中，让类实例化接口的方式（implment）的方式实现对类的功能的拓展；

（4）一个类可以实现多个接口，一个接口可以继承多个接口；但是一个类只能继承一个类，这个就是java中类的，**单继承和多实现**的体现；

**接口和抽象类的异同：**

（1）接口和抽象类都不能被实例化；都包含抽象方法；

（2）接口只包含抽象方法、静态方法和默认方法，不能为普通方法提供方法实现；

（3）接口只能定义静态常量，不能定义普通成员变量；但是抽象类，既可以定义普通成员变量，也可以定义静态常量；

（4）接口不能包含构造器；抽象类可以包含构造器（让抽象类的子类调用这些构造器来完成属于抽象类的初始化操作；

简单说，接口和抽象类都是一种规范，定义；接口是实现的对行为的规范，抽象类，实现的是对属性的规范；



**11、内部类**

​	内部类，什么是内部类，内部类就是将一个类的定义，放在另一个类的定义的内部，内部类，本身就是一个属性，和其他属性的定义方式相同；根据定义的位置不同将，内部类分为一下几种：

- **成员内部类**

定义在成员位置上的非静态内部类，就是成员内部类；

成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式外部类实例.new 内部类()

- **局部内部类**

定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式；

- **匿名内部类**

顾名思义，就是没有名字的内部类，

匿名内部类，必须继承一个抽象类，或者是实现一个接口，内部不能定义任何静态成员，静态方法；匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法，当所在的方法的形参需要被匿名内部类使用时，必须声明为 final;

- **静态内部类 ：在**类内部的 静态类，就是静态内部类；

静态内部类，可以访问外部类的所有静态属性，而不能访问外部类的非静态属性，原因是，静态内部类书随类加载而创建的，而，非静态属性，是类实例化时才创建的；

**内部类存在的意义：**

- 一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！
- 内部类不为同一包的其他类所见，具有很好的封装性；
- 内部类有效实现了“多重继承”，优化 java 单继承的缺陷。
- 匿名内部类可以很方便的定义回调。



```java
public class OutterClass {

    /**
     * 4、匿名内部类
     */
    interface Service{
        public void method();
    }
    private void testNoName(int i){
        new Service(){
            public void method(){
                System.out.println(i);
            }
        }.method();
    }

    /**
     * 3、局部内部类
     */
    public void InPartInnerClass() {
        class InpartInnerclass {
            public void testInPartInnerClass() {
                System.out.println("inPart inner class");
            }
        }

        InpartInnerclass inpartInnerclass = new InpartInnerclass();
        inpartInnerclass.testInPartInnerClass();
    }

    /**
     * 2、成员内部类
     */
    private String name = "word";

    class memberInnerClass {
        public void testMemberInner() {
            System.out.println("member inner class");
        }
    }

    @Test
    public void testMemner() {
        OutterClass outterClass = new OutterClass();
        memberInnerClass memberInnerClass = outterClass.new memberInnerClass();
        memberInnerClass.testMemberInner();
    }

    /**
     * 1、静态内部类的定义
     */
    static class StaticInnerClass {
        public void testStaticInner() {
            System.out.println("static inner class");
        }
    }


    @Test
    public void testStatic() {
        // 静态内部类的创建
        OutterClass.StaticInnerClass staticInnerClass = new OutterClass.StaticInnerClass();
        //静态内部类的方法访问
        staticInnerClass.testStaticInner();
    }

}
```



