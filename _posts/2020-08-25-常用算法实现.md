

[TOC]



# 常用算法实现

## 1、 稀疏矩阵

​	在一个较大的矩阵中，非零元素s相对于矩阵元素总个数t来说很z小时，即（s<t）;则称该矩阵为稀疏矩阵；若对稀疏矩阵中的每个元素都分配一个内存空间，则会造成极大的浪费。

​	为避免浪费，我们仅关注稀疏矩阵中的非零元素，稀疏矩阵采用三元组的方式存储，具体方式如下：

- 先扫描稀疏矩阵 ，以count记录非零元素个数；
- 声明一个二维数组count*2，第一行第一个元素记录矩阵的行数，第一行第二个元素记录矩阵的列数，第一行第三个元素记录 非零元素的个数；
- 从第二行起，第一个元素代表非零元素在原矩阵的行数，第二个元素代表非零元素在原矩阵的列数，第三个元素代表矩阵的值。 

```java
	// 稀疏矩阵转三元
	public int[][] toTri(int[][] orial){
		int row=orial.length;
		int line=orial[1].length;
		int cout=0;

		for (int i=0;i<row;i++) {
			for (int j=0;j<line ;j++ ) {
				if(orial[i][j]!=0){
					count++;
				}
			}
		}

		int[][] tri=new int[count+1][2];
		tri[0][0]=row;
		tri[0][1]=line;
		tri[0][2]=count;
		flag=0;

		for (int i=0;i<row ;i++ ) {
			for (int j=0;j<line ;j++ ) {
				if(orial[i][j]!=0){
					flag++;
					tri[flag][0]=i;
					tri[flag][1]=j;
					tri[flag][2]=orial[i][j]
				}
			}
		}
		return tri;
	}
```


```java
//三元转稀疏矩阵
	public int[][] toOri(int[][] tri){
		int row=tri[0][0];
		int line=tri[0][1];
		int count=tri[0][2];

		int[][] ori =new int[row][line];

		for (int k=0;k<count+1;k++) {
			ori[tir[k][0]][tri[k][1]]=tri[k][2];
		}

		return ori;
	}

```



## 2、 约瑟夫环

​	**问题描述**：已知n个人(以编号1，2，3...n分别表示)围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列;他的下一个人又从1开始报数，数到m的那个人又出列;依此规律重复下去，直到圆桌周围的人全部出列。

### 2.1 环形链表实现

### 2.2 使用递推公式实现

​	若是以环形链表模拟，约瑟夫环的求解算法，**若n的数量较大**，采用模拟的方式需要用**大量的时间模拟退出的过程**，并且需要**占用大量的内存空间模拟内存中的每个人**；

​	在大部分情况下，我们仅仅需要知道最后那个人的编号，而不是要来模拟一个这样的过程，在这种情况下，可以考虑是否存在着一种数学公式能够直接求出最后那个人的编号。

 - 将初始化的n个人，从0至n-1标号；

 - 第一个出列的人的标号一定为m%n-1,剩下的n-1个人，重新构成一个新的约瑟夫环，然后以编号m%n（设为K) 作为起点，重新开始编号并开始报号；

 - 原编号与新编号的之间的映射关系

   原编号：k、k+1、k+2......n-1、0、1、k-3、k-2

   新编号：0、1、2、3......n-k-1、n-k、n-k+1、n-3、n-2

   综上，就是将原问题中的n ，替换成 n-1;

   设最终胜利的那个人在这种编号环境里（已经出列一个元素，编号范围为0 ------- n-2）的编号为x;

   则我们可以求出这个人在原编号环境（初始编号范围 0----n-1）下的编号（x+k）%n;递推可得；

$$
f(n,m)=\begin{cases} 0,(n=1)\\ [f(n-1,m)+m]\%n， (n>1)\end{cases}
$$



- 方法一：递归的方式实现

```java
	// n 表示有 n个人
	//m表示数 m次
	public int JoseLoop(int n,int m){
		if (n==0){
			return -1;
		}else if(n==1){
			return 1;
		}else{
			return JoseLoop(n-1,m);
		}
	}

```

- 方法二： 内循环

```java
// n 表示有 n个人
//m表示数 m次
public int JoseLoop(int n, int m) {
	        if(n == 0 || m <= 0) {
	            return -1;
	        }
	        int last = 0;
	        for(int i = 2; i <= n; i++) {
	            last = (last + m) % i;
	        }
	        return last;
	    }
```

## 3、中缀表达式转后缀

​	**中缀表达式：**日常我们常见的数学表达式（1+2*3），操作数在运算符两边，便于我们日常理解，但不方便计算机进行运算；

​	**后缀表达式：**操作数在前，运算符在后，计算机方便理解的表达式（123*+）；

​	**中缀表达式转为后缀表达式**：从**左到右**遍历中缀表达式的每一个数字和符号，若是数字就输出，即为后缀表达式中的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号则栈顶元素（符号）依次出栈并输出并将当前符号进栈（ps：若当前符号优先级与栈顶相同则弹出栈顶元素并输出），一直到最终输出后缀表达式为止。

1. 初始化两个栈**operatorStack(存放运算符)，numberStack(存放中间结果)**

2. 从左至右扫描中缀表达式；

3. 遇到操作数时压入numberStack;

4. 遇到运算符时，比较其与operatorStack栈顶元素的优先级；

   4.1若operatorStack为空，或operatorStack栈顶元素为“（”，则直接入栈；

   4.2若其比operatorStack栈顶元素优先级高，直接入栈；

   4.3 否则，将operatorStack栈顶的运算符弹出并压入到numberStack中，再次转到(4.1)与operatorStack中新的栈顶运算符相比较；

5. 遇到括号时：

   5.1如果是左括号“(”,直接压入；

   5.2如果是右括号“)”，则依次弹出operatorStack栈顶的运算符，并压入numberStack，直到遇到左括号为止，此时将这一对括号丢弃；

6. 重复依次扫描2-5步骤，直至表达式最右边；

7. 将operatorStack中剩余的运算符依次弹出并压入numberStack；

8. 依次弹出numberStack中的元素并输出，结果的**逆序即为**中缀表达式对应的后缀表达式;

**ForExample:**    **9+（3-1）*3+10/2**

  (1) 从左至右扫描，将9输出，+ （入栈； 输出：9

 (2) 遇到3输出，( - 入栈 ，1输出； 输出：9 3 1

 (3) 遇到运算符），因此 - 出栈并输出； 输出：9 3 1 -

 (4) 接下来是 * 运算符入栈，优先级高于 + ，因此不输出； 输出：9 3 1 -

 (5) 3输出，遇到 + ，优先级低于 * ，所以* 输出； 输出：9 3 1- 3*

 (6)没有比+ 更低优先级，所以全部出栈，并将当前符号“+” 进栈； 输出：9 3 1 -3 * +

 (6) 将10输出，/ 入栈 ，优先级高于 + 不输出； 输出 ：9 3 1 - 3* +10

 (7) 接下来是2输出，没有其他运算符入栈，所有运算符出栈并输出； 输出： 9 3 1 - 3*+10 2 /+

```java
	 /**
     *  将表达式转化为中缀表达式
     * @param expression  表达式
     * @return
     */
    public static List<String> toInfixExpressionList(String expression){
        List<String>  list = new ArrayList<String>();
        int index = 0;
        while(index < expression.length()){
            char ch = expression.charAt(index);
            if((ch < 48) || (ch > 57)){//当前字符非数字
                list.add(ch+"");
                index++;
            }else{//当前字符是数字
                String str = "";
                //查看当前字符下一位是不是数字
                while (index<expression.length() && expression.charAt(index) >= 48 && expression.charAt(index) <= 57){
                    str += ch;
                    index++;
                }
                list.add(str);
            }
        }
        return list;
    }


	/*
	* 设置操作符优先级
	*/
	public int operatorPriority(String operatior){
		int result=0;
		switch(operatior){
			case"+":
				result=1;
				break;
			case"-":
				result=1;
				break;
			case"*":
				result=2;
				break;
			case"/":
				result=2;
				break;
			case"%":
				result=2;
				break;
			default:
				System.out.println("不存在该运算符")；
				break;
		}

	}

	/*
	*中缀表达式转后缀表达式
	*/
	public List<String> toSuffixExpression(List<String> list){
		Stack<String> operatiorStack=new Stack<>();// 运算符栈
		Stack<String> numberStack=new Stack<>(); //存放中间结果栈

		for (String item:list) {
			if(item.matchs("\\d+")){// 若当项是数字，则进入运算数栈
				numberStack.push(item);
			}else if(item.equals("(")){//若当前项是"(",入运算符栈
				operatiorStack.push(item);
			}else if(item.equals(")")){// 若当前项是")",出运算符栈，入运算数栈，直至匹配到"("
				while(!operatiorStack.peek().equals("(")){
					numberStack.push(operatiorStack.pop())
				}
				operatiorStack.pop();	
			}else{//如果运算符栈不为空，且运算符栈栈顶元素优先级大于当前运算符优先级，则运算符栈出，运算数栈入；
				while(!operatiorStack.empty()&&operatorPriority(operatiorStack.peek())>=operatorPriority(item)){
					numberStack.push(operatiorStack.pop());
				}
				operatiorStack.push(item);
			}
		}
		while(!operatiorStack.empty()){//将 运算符栈相关元素压入运算数栈
			numberStack.push(operatiorStack.pop());
		}
		return numberStack;
		//最后将运算数栈相关元素逆序输出，则得到后缀表达式（逆波兰表达式）
	}


	/*
	*后缀表达式计算结果
	*/
	public int caculate(List<String> list){
		Stack<String> stack=new Stack(String);

		for (String item:list) {
			if(item.matchs("\\d+")){// 遇到运算数则直接入栈
				stack.push(item);
			}else{ //与操作符，则，栈顶两个元素出栈
				int num1=Integer.parseInt(stack.pop()); //
				int num2=Integer.parseInt(stack.pop());
				int sum=0;
				if(item.equals("-")){
					sum=num2-num1;
				}else if(item.equals("+")){
					sum=num1+num2;
				}else if(item.equals("*")){
					sum=num1*num2;
				}else if(item.equals("/")){
					sum=num2/num1;
				}
				stack.push(sum);//计算结果入栈
			}
		}
		return Integer.parseInt(stack.pop());
	}

```

## 4、链表的相关操作

### 4.1 获取单链表的倒数第K个节点

### 4.2 将两个有序单链表合并

​	将两个有序的链表合并为一个新链表，要求新的链表是通过拼接两个链表的节点来生成的。

```java
public class ListNode {
    int val;
    ListNode next = null;

}

// 递归实现
public ListNode mergeTwoLisdt(ListNode l1,ListNode l2){
    if (l1==null&& l2==null){
        return null;
    }
    if (l1==null){
        return l2;
    }
    if (l2==null){
        return l1;
    }

    ListNode l3=null;
    if (l1.val>l2.val){//比较两个节点的值的大小
        l3=l2;
        l3.next=mergeTwoLisdt(l1,l2.next);
    }else{
        l3=l1;
        l3.next=mergeTwoLisdt(l1.next,l2);
    }

    return l3;
}
```

## 5、栈的使用

​	8皇后问题；8X8的棋盘，上有八个皇后，各个皇后之间，不能处在同一行，或者同一列，或者处在同一对角线上，问一共有多少种解法；

思路：先将第一个皇后房子啊第一行第一列

第二个皇后放在第二行第一列，判断是否可行，若是不可行，则放在第二行，第二列，依次把所有的列数都尝试一遍，直到找到一个合适的位置

第三个皇后，参照第二个皇后的操作，类似；

说明：本该用一个二维数组，来模拟棋盘，但是，在算法实现中，可以用一个一维数组；

Arr[]={1,4,6,3,8,2,0,5}.  //处在第几位，就表示在第几行，数字的大小就表示在第几列；



## 6、排序算法

​	排序算法，就是将一组数据，依照指定的顺序，进行排列的过程；

​	大致可以分为两类，**内部排序**（将所有数据，都加载到内存中）进行排序；**外部排序**，（数据 量过大，无法加载到内存中，需要借助外部存储）进行排序；

​	常见的排序：

	- 内部排序 插入排序（直接插入排序、希尔排序）、选择排序（简单选择排序、堆排序）、交换排序（冒泡排序、快速排序）、归并排序、基数排序；
	- 外部排序；

**算法的时间复杂度：**

- 事后统计
- 事情估算

时间复杂度，当n无限大的时候，可以忽略次常数项、低次项、高次项的系数也可以忽略；

**常见的时间复杂度：**

O(1)<Ologn<O(n)<O(nlogn)<O(n*n)<0(n***n*n)<O(n的k次方)<O(2 的n次方)

- 常数阶：无论代码执行多少行，只要没有循环等复杂结构，这个代码的时间复杂度就是O（1）；

- 对数阶：O(logn)

  ```java
  while(i<n){
      i=i*2;
  }
  ```

- 线性阶O（n）

  ```java 
  for(int i=0;i<n;i++){}
  ```

- 线性对数阶

  ```java
  for(int i=0;i<n;i++){
  	while(j<n){
  		j=j*2;
  	}
  }
  ```

- 平方阶

  ```java
  for(int i=0;i<n;i++){
  	for(int j=0;j<n;j++){
  		j=i;
  		j++;
  	}
  }
  ```

  

**平均时间复杂度、最坏时间复杂度**

**平均时间复杂度**：所有可能输入实例以等概率出现的情况下，该算法运行的时间；

**最坏时间复杂度**：最坏的情况下的输入，该算法的运行时间，一般，情况下，我们关注的是就是最坏时间复杂度；



### 6.1 冒泡排序

​	通过对，待排序的序列，从前向后（由下标较小的元素开始），一次比较相邻元素的值，若发现逆序，则交换；值较大的元素逐渐从前面的到后面移动，就像水底的气泡一样；

```
- 一共进行数组-1 次的大循环；
- 循环次数逐渐减少；
- 如果发现在某趟排序中，没有发生一次交换，则，可以提前结束冒泡排序；（优化）
```

**基本版：**

```java
public static int[] bubbleSort(int arr[]) {
    int temp;
    for (int i = 0; i < arr.length - 1; i++) {//大循环，需要进行多少次排序
        for (int j = 0; j < arr.length - 1-i; j++) {
            if (arr[j] > arr[j + 1]) {
                temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }
        }
    }
    return arr;
}
```

**优化版：**

```java
public static int[] bubbleSort2(int arr[]) {
    int temp;
    boolean flag=false;  //定义一个变量，判断是否交换；
    for (int i = 0; i < arr.length - 1; i++) {
        for (int j = 0; j < arr.length - 1-i; j++) {
            if (arr[j] > arr[j + 1]) {
                flag=true;
                temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }
        }

        System.out.println("the " +(i+1)+ " circule");
        System.out.println(Arrays.toString(arr));

        if (flag==false){//在排序中一次都没有交换过
            break;
        }else{
            flag=false; //重制flag，进行下一次判断；
        }
    }
    return arr;
}
```

### 6.2 选择排序

​	选择排序是指，从虚排序的数组中，按照指定规则选出某一元素，再依规定交换位置后达到排序的目的；

**第一次：**从a r r[0]-arr[n-1] 之间，选出最小值，与arr[0]交换位置；

**第二次：**从arr[1]-arr[n-1]之间选出最小值，与arr[1]交换位置；

........

依次类推，求出由小至大的一个有序数列；

选择排序，一共有数据.size -1轮排序；

```java
public static int[] seleteSort(int[] arr) {

    for (int j = 0; j < arr.length - 1; j++) {

        int min = arr[j];
        int minIndex = j;

        for (int i=j+1; i < arr.length; i++) {
            if (min > arr[i]) {
                min = arr[i];
                minIndex = i;
            }
        }

        // 正好，最小值处在数组首位
        if (minIndex!=j){
            arr[minIndex]=arr[j];
            arr[j]=min;
        }

    }

    return arr;
}
```

### 6.3 插入排序

​	将欲排序的元素以插入的地方时寻找该元素的适当的位置；将n个待排序的元素看成一个有序表，和一个无需表 ，开始的时候，有序列表中，只包含一个元素，无序表中有 n-1个元素，排序过程中，每次从无序表中取出一个元素，把它依次和有序表中元素进行比较，并将其插入到有序表中合适的位置，使其成为新的有序表；

```java
public static int[] insertSort(int[] arr) {
    /**
     * 1、insertIndex.=o 保证数组不越界
     * 2、insertVal<arr[insertIndex 待插入的数，还没找到插入的位置
     */

    for (int i = 1; i < arr.length; i++) {//默认 数组第一个数为有序，从第二个数开始比较并插入
        int insertVal = arr[i];  //记录待出入的值
        int insertIndex = i - 1;//记录待插入的位子

        while (insertIndex >= 0 && insertVal < arr[insertIndex]) {//如果插入的那个数比他前一个数小则，进入循环
            arr[insertIndex + 1] = arr[insertIndex];  //将插入的那个数的前一个数后移
            insertIndex--;
        }

        arr[insertIndex + 1] = insertVal;
    }

    return arr;
}
```

### 6.4 希尔排序

​	是一种对希尔排序对插入排序一种优化的排序，也称**缩小增量排序**；

**交换法**

```Java
public static int[] shellSort1(int[] arr) {

    for (int gap = arr.length / 2; gap > 0; gap /= 2) {//确定单步步长，将数组分组；
        for (int i = gap; i < arr.length; i++) {
            for (int j = i - gap; j >= 0; j -= gap) {
                if (arr[j] > arr[j + gap]) {
                    int temp = arr[j] + arr[j + gap];
                    arr[j + gap] = temp - arr[j + gap];
                    arr[j] = temp - arr[j];
                }
            }
        }
    }

    return arr;
}
```

移位法

```java
public static int[] shellSort2(int[] arr) {
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < arr.length; i++) {
            int j = i;
            int temp = arr[j];
            if (arr[j] < arr[j - gap]) {
                while (j - gap >= 0 && temp < arr[j - gap]) {  //对 分段后的数据，进行插入排序
                    arr[j] = arr[j - gap];
                    j -= gap;
                }
                //退出while循环后就找到了位子
                arr[j] = temp;
            }
        }
    }
    
    return arr;
}
```

### 6.5 快速排序

​	快排是对冒泡排序的一种改进；**基本思想：**通过一趟排序，将要排序的数据分割成独立的两个部分，其中一部分的所有数据比另一部分的所有数据要小，然后再按此方法，对这两部分分别进行快速排序。

```java
public static int[] quickSDort(int[] arr, int left, int right) {

    int l = left;//记录做下标
    int r = right;//记录右下标
    int pivot = arr[(left + right) / 2]; //中轴
    int temp = 0;// 临时变量，用于交换使用

    while (l < r) {// while 目的是让 pivot将数组划分为左右两边
        while (arr[l] < pivot) {// pivot 左边找比pivot大的数据，然后退出  从左往右扫描
            l += 1;
        }
        while (arr[r] > pivot) {//在pivot右边找比pivot小的数据，然后退出  从右往左扫描
            r -= 1;
        }
        if (l >= r) {  //若满足次条件，则说明，pivot 左边的数均比右边的小，则退出
            break;
        }

        //交换两个值
        temp = arr[l] + arr[r];
        arr[l] = temp - arr[l];
        arr[r] = temp - arr[r];

        if (arr[l] == pivot) {//如果交换完之后arr[l]==pivot相等，则前移 r--
            r -= 1;
        }

        if (arr[r] == pivot) {//如果交换完之后arr[r]==pivot相等，则后移 l++
            l += 1;
        }

        //以上两个判断是为了避免，l和r的值都等于pivot，为了避免死循环

    }


    //如果l==r 必须要 l++ ，以及r-- 否则会出现栈溢出；
    if (l == r) {
        l++;
        r--;
    }

    //向左递归
    if (left < r) {
        quickSDort(arr, left, r);
    }

    //向右递归
    if (right > l) {
        quickSDort(arr,l,right);
    }
    return arr;
}
```

### 6.6 归并排序

​	采用分治算法，将一个大的问题分解成多个小问题，然后将问题解决；

### 6.7 基数排序

​	基数排序：将整数切割成不同的位数，然后在根据位数进行比较；从低位开始，依次进行一次排序；这样从低位到高位一次完成排序后，数列就有序了，将所有的带比较数值，统一为同一数位长度，数位较短的在前面补0；

## 7、查找算法

### 7.1 线性查找

### 7.2 二分查找

​	首先，二分查找要求数组有序；思路如下：

- 确定数组中间下标
- Find value 与a r r[mid]比较
- Find vale >arr[mid]. 向右递归
- findvalue<arr[mid]向左递归
- findvale=arr[mid] 找到

递归出口：

- 目标数据已查到，退出；
- 当left>right 表示，没有找到相关数据，退出

```java
/**
 *
 * @param arr 已经有序的数组
 * @param left 左下标
 * @param right 右下标
 * @param findval 待查找的值
 * @return  返回-1 代表未找到
 */
public static int BinarySearch(int[] arr, int left, int right, int findval) {

    if (left>right){
        return -1;
    }

    int mid=(left+right)/2;
    int midValue=arr[mid];

    if (findval>midValue){  //向右递归
        return BinarySearch(arr,mid+1,right,findval);
    }else if (findval<midValue){  //向左递归
        return BinarySearch(arr,left,mid-1,findval);
    }else (findval==midValue){  //已找到
        return mid;
    }
}
```

```java
/**
 * 对二分查找的优化，在数组中有多个数存在，则，返回这个所在下标的集合
 * @param arr 
 * @param left
 * @param right
 * @param findval
 * @return
 */
public static ArrayList<Integer> BinarySearch1(int[] arr, int left, int right, int findval) {

    if (left > right) {
        return new ArrayList<Integer>();
    }

    int mid = (left + right) / 2;
    int midValue = arr[mid];

    if (findval > midValue) {  //向右递归
        return BinarySearch1(arr, mid + 1, right, findval);
    } else if (findval < midValue) {  //向左递归
        return BinarySearch1(arr, left, mid - 1, findval);
    } else (findval == midValue) {  //已找到
        ArrayList<Integer> arrayList = new ArrayList<>();
        int temp = mid - 1;
        while (true) {
            if (temp < 0 || arr[temp] != findval) {
                break;
            }
            arrayList.add(temp);
            temp--;
        }

        arrayList.add(mid);

        temp = mid + 1;
        while (true) {
            if (temp > 0 || arr[temp] != findval) {
                break;
            }
            arrayList.add(temp);
            temp++;
        }
        return arrayList;
    }
}
```

### 7.3 差值查找

​	二分查找的弊端：若是查找有序数列的头尾的值，茶斋	

差值查找类似于二分查找，常规的二分查找方式，简单说就是让mid 不断向目标值逼近;

**mid=1/2*(left+right)=> mid=low+1/2(left+right)；**

差值查找与之类似，但是，起修改了逼近的方式：

**mid=low+(findVal-arr[left])/(arr[right]-arr[right]) * (right-left);**



### 7.4 斐波那契 查找

## 8、哈希表

​	哈希表也称为散列表是根据关键码值，而直接进行访问的数据结构，，通过将关键码映射到表的摸一个位置进行访问，可以加快查找速度，这个映射函数也叫**散列函数**，存放记录的数组也叫**散列表**；

**例子：**

新员工报道，要求录入新员工信息，当输入员工ID时，找到该员工所有信息；

**要求：**

1、不使用数据库

2、升序排列；

## 9、树

分析顺序存储，以及链式存储的优劣势，树方便存储与读取；

### 9.1 二叉树

每个节点最多只有两个节点，，若二叉树的所有节点都在最后一层，并且节点的总数为 2^n -1 (n为层数)，则该二叉树称为**满二叉树**；

若二叉树的所有叶子结点都在最后一层，或倒数第二层，且最后一层叶子结点在左边连续，倒数第二层叶子结点在右边连续，**则称此二叉树为完全二叉树；**

#### 9.1.1 二叉树遍历

**前序遍历：**先输出父节点、再遍历左子树和右子树；

**中序遍历：**先遍历左子树，在输出父节点，再遍历右子树；

**后续遍历：**先遍历左子树。再遍历右子树，最后输出父节点；

**思路分析：**

1、创建二叉树

**2、前序遍历**

2.1输出当前节点

2.2 左子节点不为空，递归前序遍历

2.3右子节点不为空，递归前序遍历；

**3、中序遍历**

3.1左子节点不为空，中序遍历左子节点

3.2输出当前节点

3.3 右子节点不为空，中序遍历右子节点；

**4、后续遍历**

4.1 左子节点不为空，后续遍历左子节点；

4.2 右子节点不为空，后续遍历右子节点

4.3 输出当前节点；

代码实现

```java
// 1、 定义节点，并在节点中定义，前、中、后、三种遍历方式
class Node {
    int id;
    String Name;

    Node left;
    Node right;

    public Node() {
    }

    public Node(int id, String name) {
        this.id = id;
        Name = name;
    }

    public Node(int id, String name, Node left, Node right) {
        this.id = id;
        Name = name;
        this.left = left;
        this.right = right;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return Name;
    }

    public void setName(String name) {
        Name = name;
    }

    public Node getLeft() {
        return left;
    }

    public void setLeft(Node left) {
        this.left = left;
    }

    public Node getRight() {
        return right;
    }

    public void setRight(Node right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "Node{" +
                "id=" + id +
                ", Name='" + Name + '\'' +
                '}';
    }

    // 前序遍历
    public void preOrder() {
        System.out.println(this);
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null) {
            this.right.preOrder();
        }
    }

    // 中序遍历
    public void inFixOrder() {
        if (this.left != null) {
            this.left.inFixOrder();
        }
        System.out.println(this);
        if (this.right != null) {
            this.right.inFixOrder();
        }
    }

    //后续遍历
    public void postOrder() {
        if (this.left != null) {
            this.left.postOrder();
        }
        if (this.right != null) {
            this.right.postOrder();
        }
        System.out.println(this);

    }

}
```



```java 

// 定义一个二叉树
class BinaryTree{
    Node root;

    public void setRoot(Node root){
        this.root=root;
    }

    //前序遍历
    public void preOrder(){
        if (this.root!=null){
            this.root.preOrder();
        }else {
            System.out.println("Tree is Empty");
        }
    }


    //中序遍历
    public void inFixOrder(){
        if (this.root!=null){
            this.root.inFixOrder();
        }else {
            System.out.println("Tree is Empty");
        }
    }

    // 后续遍历
    public void postOrder(){
        if (this.root!=null){
            this.root.postOrder();
        }else {
            System.out.println("Tree is Empty");
        }
    }
}
```



```java
//3、测试
@Test
public void test01(){
    
    //手动 生成二叉树
    BinaryTree binaryTree = new BinaryTree();
    Node root = new Node(1, "xiaoming");
    Node node2 = new Node(2, "xiaofang");

    Node node3 = new Node(3, "xiaogang");
    Node node4 = new Node(4, "xiaowang");


    binaryTree.setRoot(root);
    root.setLeft(node2);
    root.setRight(node3);
    node2.setRight(node4);

  //  binaryTree.preOrder();
   // binaryTree.postOrder();


}
```



#### 9.1.2 二叉树查找

编写前、中、后三种查找方法，并对查找方法进行比较；

思路分析：

前、中、后三种查找方法进行检索，检索指定ID的节点；

**前序查找：**

1、判断当前节点ID是否等于指定ID；

2、若相等则返回当前节点

3、若不相等，则：判断左子节点是否为空，不为空左子节点递归前序查找；

4、若左递归找到目标节点，则返回；

5、若未找到，则右递归 前序查找；

6、若未找到则返回 null ；

```java
//前序查找

public Node preSearch(int no) {

    // 定义一个变量记录返回值
    Node resNode = null;
    if (this.id == no) {
        return this;
    }
    if (this.left != null) {
        resNode = this.left.preSearch(no);
    }
    if (resNode != null) {
        return resNode;
    }
    if (this.right!=null){
        resNode = this.right.preSearch(no);
    }
    return resNode;

}
//中序查找
public Node inFixSearch(int no){
    Node resNode=null;
    if (this.left!=null){
        resNode=this.left.inFixSearch(no);
    }
    if (this.id==no){
        return this;
    }
    if (this.right!=null){
        resNode=this.right.inFixSearch(no);
    }
    return resNode;
}


//后续遍历
public Node postSearch(int no){
    Node resNode=null;
    if (this.left!=null){
        resNode=this.left.postSearch(no);
    }

    if (resNode!=null){
        return resNode;
    }

    if (this.right!=null){
        resNode=this.right.postSearch(no);
    }
    if (this.id==no){
        return this;
    }
    return resNode;

}
```

#### 9.1.3 删除节点

1、若删除节点是叶子结点直接删除；

2、若是非叶子结点直接删除，子树

```java
//递归删除结点
  //1.如果删除的节点是叶子节点，则删除该节点
  //2.如果删除的节点是非叶子节点，则删除该子树
  public void delNode(int no) {

      //思路
/*
 *     1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.
   2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)
   3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)
   4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除
   5.  如果第4步也没有删除结点，则应当向右子树进行递归删除.

 */
      //2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)
      if (this.left != null && this.left.no == no) {
          this.left = null;
          return;
      }
      //3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)
      if (this.right != null && this.right.no == no) {
          this.right = null;
          return;
      }
      //4.我们就需要向左子树进行递归删除
      if (this.left != null) {
          this.left.delNode(no);
      }
      //5.则应当向右子树进行递归删除
      if (this.right != null) {
          this.right.delNode(no);
      }
  }
```

### 9.2 顺序存储二叉树

​	从数据的存储来看，数据的存储放肆和树的存储方式可以相互转换，及数组和树可以相互转换；二叉树的数据依旧以数组大方式存储，但是遍历的时候，可以前序，中序，后续完成遍历；

**顺序存储二叉树的特点**：

仅考虑完全二叉树，第n个元素的左子节点为 2*n+1,右子节点为 2*n+2,第n个元素的父节点为（n-1）/2;(n二叉树中第n个元素，按0开始编号)

```java
package com.restart.tree;

import org.junit.jupiter.api.Test;

/**
 * @author : Evens
 * @description:
 * @date : ${Date}
 */
public class ArrBinaryTree {

    int[] arr;

    public ArrBinaryTree(int[] arr) {
        this.arr = arr;
    }

    /**
     * 前序遍历
     *
     * @param index
     */
    public void preOder(int index) {
        if (arr == null || arr.length == 0) {
            System.out.println("empty");
        }
        System.out.println(arr[index]);

        if ((index * 2 + 1) < arr.length) {
            preOder(index * 2 + 1);
        }
        if ((index * 2 + 2) < arr.length) {
            preOder(index * 2 + 2);
        }
    }

    /**
     * 中序遍历
     *
     * @param index
     */
    public void mindOrder(int index) {
        if (arr == null || arr.length == 0) {
            System.out.println("empty");
        }

        if ((index * 2 + 1) < arr.length) {
            preOder(index * 2 + 1);
        }
        System.out.println(arr[index]);
        if ((index * 2 + 2) < arr.length) {
            preOder(index * 2 + 2);
        }

    }


    /**
     *后续
     * @param index
     */
    public void suffixOrder(int index) {
        if (arr == null || arr.length == 0) {
            System.out.println("empty");
        }

        if ((index * 2 + 1) < arr.length) {
            preOder(index * 2 + 1);
        }

        if ((index * 2 + 2) < arr.length) {
            preOder(index * 2 + 2);
        }

        System.out.println(arr[index]);

    }

    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7};
        ArrBinaryTree binaryTree = new ArrBinaryTree(arr);
        binaryTree.preOder(0);
        binaryTree.mindOrder(0);
        binaryTree.suffixOrder(0);
    }

}
```

### 9.3 线索化二叉树

​	n个节点的二叉脸变中含有n+1【2n-(n-1)】个空指针域，利用二叉脸表中的空指针域，存放指向该节点的某种遍历次序下的前驱和后继节点的指针（这种附加的执行称为线索）；

​	这种加上限速的二叉链表，称为线索链表，线索二叉树可以分为前序线索、中序线索、后续线索二叉树；前驱、后继；

## 10、堆排序

  堆排序，是利用堆这只能数据接否二设计的一种排序算法，堆排序是一种选择排序，其最好、最坏、平均时间复杂度为

O(nlogn)是一种不稳定 排序；

堆是满足以下性质的完全二叉树：每个几点的值都大于或者等于其左右孩子节点的值，称为大顶堆，（没有要求做几点和右节点的值的大小关系）；每个节点的值都小于或等于左右孩子节点的值，称为小顶堆；

**大顶堆的特点：**(若采用线性存储)

Arr[i]>=arr[2i+1]. && arr[i]>=arr[2i+2];

小顶堆的特点：

Arr[i]<=arr[2i+1]. && arr[i]<=arr[2i+2];

 

**堆排序的基本思想**（以大顶堆举例）

1、将待排序列构造一个大顶堆，此时整个序列的最大值就是堆顶节点的跟节点；

2、将最大值与末尾元素进行交换，此时末尾元素就是最大值；

3、然后将剩余的n-1个节点重新构造一个堆，这样就会得倒n个元素的次小值，反复执行，就可以得到一个有序序列；

```java
public class HeapSort {
    @Test
    public void test() {
        int[] arr = {4, 6, 8, 5, 9};
        heapSort(arr);
    }

    /**
     * 从上往下，从左至右扫描
     * @param arr
     */

    public static void heapSort(int[] arr) {
        int temp = 0;
        for (int i = arr.length / 2 - 1; i >= 0; i--) {  // 找到非叶子节点
            adjustHeap(arr, i, arr.length);
        }

        for (int j = arr.length-1; j > 0; j--) {
            temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;
            adjustHeap(arr, 0, j);
        }
        System.out.println(Arrays.toString(arr));
    } 

    /**
     * @param arr    待调整的数组
     * @param i      非叶子系带女在数组中的索引
     * @param length 表示对多少个元素进行调整
     */
    public static void adjustHeap(int[] arr, int i, int length) {
        int temp = arr[i];  // 取出当前元素的值，，保存在临时变量中；
        for (int k = i * 2 + 1; k < length; k = k * 2 + 1) {
            if (k + 1 < length && arr[k] < arr[k + 1]) {  //1、先比较当前节点的 左右子节点的大小，取得其中的最大值
                k++;
            }
            if (arr[k] > temp) { //2、用左右子节点的最大值与 当前节点比较，若子节点的值大，则交换；
                arr[i] = arr[k];
                i = k;
            } else {
                break;
            }
        }
        // for 循环结束后，就已经将以i 为父节点的值放在局部堆顶

        arr[i] = temp;//将temp的值放在调整后的位置上；
    }
}
```

## 11、霍夫曼树

给定n个权值作为n个叶子结点，构造一颗二叉树，若该树的带权路径长度达到最小，称这样的书为最优二叉树，也称为霍夫曼树，权值较大的节点离跟节点较近；

路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1;

**结点的权及带权路径长度：**若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。**结点的带权路径长度**为：从根结点到该结点之间的路径长度与该结点的权的乘积

**树的带权路径长度：**树的带权路径长度规定为所有**叶子结点**的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。

**WPL**最小的就是赫夫曼树;

{13, 7, 8, 3, 29, 6, 1} 

**构成赫夫曼树的步骤：**

1)从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树

2)取出根节点权值最小的两颗二叉树 

3)组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 

4)再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树

```java
public class HuffmanTree {
    class Node implements Comparable<Node> {
        int value;
        Node left;
        Node right;

        public Node(int value) {
            this.value = value;
        }

        public Node(int value, Node left, Node right) {
            this.value = value;
            this.left = left;
            this.right = right;
        }

        public Node() {
        }

        @Override
        public String toString() {
            return "Node{" +
                    "value=" + value +
                    ", left=" + left +
                    ", right=" + right +
                    '}';
        }

        @Override
        public int compareTo(Node o) {
            return this.value - o.value;
        }
    }

    /**
     *
     * @param arr 待构造成霍夫曼树的节点
     * @return 霍夫曼树的根节点
     */
    public Node createHuffmanTree(int[] arr) {
        //1、创建一个列表存放 Node 节点
        ArrayList<Node> nodes = new ArrayList<>();

        for (int val : arr) {
            nodes.add(new Node(val));
        }

        while (nodes.size() > 1) {
            // 1、排序
            Collections.sort(nodes);

            //2、获取排序后第一 二 小的节点
            Node rightNode = nodes.get(0);
            Node leftNode = nodes.get(1);

            //3、构造一个新节点，。权值为 上面两个权值之和
            Node parent = new Node(rightNode.value + leftNode.value);

            //4、将新节点加入列表，并将以及计算权值的了两个节点从列表中移除
            nodes.add(parent);

            parent.left = leftNode;
            parent.right = rightNode;

            nodes.remove(0);
            nodes.remove(1);

        }
        // 最后返回根节点
        return nodes.get(0);
    }

}
```

##  12、霍夫曼编码

1、传输字符串 ：i like like like java do you like a java    // 共40个字符(包括空格)

2、统计字符串中各个字符出现的次数：d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5  :9 // 各个字符对应的个数

3、按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值；

4、根据霍夫曼树进行编码，规定，向左的作为0，向右的作为1；

![image-20201214183151851](/Users/anner/Library/Application Support/typora-user-images/image-20201214183151851.png)

o: 1000  u: 10010 d: 100110 y: 100111 i: 101

a : 110   k: 1110  e: 1111    j: 0000    v: 0001

l: 001     : 01

5、按照上面的赫夫曼编码，我们的"i like like like java do you like a java"  字符串对应的编码为 (注意这里我们使用的无损压缩)

1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110 通过赫夫曼编码处理 长度为 133

6、 长度为 ： 133 

说明:原来长度是 359 , 压缩了 (359-133) / 359 = 62.9%，此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性赫夫曼编码是无损处理方案;

**实例：**

**功能： 根据赫夫曼编码压缩数据的原理，需要创建 "i like like like java do you like a java" 对应的赫夫曼树**

**思路:**

(1) Node { data (存放数据)， weight (权值)， left 和 right }

(2) 得到 "i like like like java do you like a java"  对应的 byte[] 数组

(3) 编写一个方法，将准备构建赫夫曼树的Node 节点放到 List , 形式 [Node[date=97 ,weight = 5], Node[]date=32,weight = 9]......], 体现 d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5  :9 

(4) 可以通过List 创建对应的赫夫曼树

## 13、二叉排序树

数据存储方式：

数组、查找速度快，但是插入速度较慢，需要有大量的移动；

链表、插入快，但是查找速度较慢；

树、提高数据的插入、读取效率；

二叉排序树：对于二叉排序树，的任何一个非叶子结点要求做子节点的值比当前节的值小，右子节点呗当前节点的值大；若值相同，放在左右节点都可以；

### 13.1 二叉排序树的生成及遍历

```java
public class BinarySearchTree {

    // 1、定义Node节点
    class Node {
        int value;
        Node left;
        Node right;

        public Node(int value) {
            this.value = value;
        }

        @Override
        public String toString() {
            return "Node{" +
                    "value=" + value +
                    '}';
        }

        /**
         * 添加节点方法
         *
         * @param node 待加入的节点
         */
        public void add(Node node) {
            //若待添加节点为空，直接返回
            if (node == null) {
                return;
            }
            //若待添加的节点值小于当前节点值，向左子树添加
            if (node.value < this.value) {
                if (this.left == null) {
                    this.left = node;
                } else {
                    this.left.add(node); //左子节点递归添加
                }
                // 若待添加的节点值大于等于当前节点，向右子树添加
            } else {
                if (this.right == null) {
                    this.right = node;
                } else {
                    this.right.add(node);
                }
            }
        }

        /**
         * 中序遍历
         */
        public void infixOrder() {
            if (this.left != null) {
                this.left.infixOrder();
            }
            System.out.println(this);
            if (this.right != null) {
                this.right.infixOrder();
            }
        }


    }

    //2、创建二叉排序树
    class BinarySerTree{
        private Node root;

        public BinarySerTree() {
        }

        public BinarySerTree(Node root) {
            this.root = root;
        }

        //添加节点
        public void add(Node node){
            if (root==null){
                root=node;
            }else {
                root.add(node);
            }
        }

        public void infixOrder(){
            if (root!=null){
                root.infixOrder();
            }else {
                System.out.println("树为空");
            }
        }
    }
    
    //3、测试
    @Test
    public  void test () {
        int[] arr={7,3,10,12,5,1,9};
        BinarySerTree binarySerTree = new BinarySerTree();

        for (int i=0;i<arr.length;i++){
            binarySerTree.add(new Node(arr[i]));
        }

        binarySerTree.infixOrder();

    }

}
```

### 13.2 二叉排序树结点删除

**三种情况需要考虑：**

**1、待删除的节点为叶子节点；**

**2、待删除节点只有一颗子树；**

3、待删除节点有两颗子树；

![image-20201217134808249](/Users/anner/Library/Application Support/typora-user-images/image-20201217134808249.png)

**第一种情况:**

删除叶子节点 (比如：2, 5, 9, 12)

思路

(1) 需求先去找到要删除的结点 targetNode

(2) 找到targetNode 的 父结点 parent 

(3) 确定 targetNode 是 parent的左子结点 还是右子结点

(4) 根据前面的情况来对应删除

左子结点 parent.left = null

右子结点 parent.right = null;

**第二种情况:** **删除只有一颗子树的节点** **比如** **1**

思路

(1) 需求先去找到要删除的结点 targetNode

(2) 找到targetNode 的 父结点 parent 

(3) 确定targetNode 的子结点是左子结点还是右子结点

(4) targetNode 是 parent 的左子结点还是右子结点

(5) 如果targetNode 有左子结点

5. 1 如果 targetNode 是 parent 的左子结点

parent.left = targetNode.left;

5.2 如果 targetNode 是 parent 的右子结点

parent.right = targetNode.left;

(6) 如果targetNode 有右子结点

6.1 如果 targetNode 是 parent 的左子结点

parent.left = targetNode.right;

6.2 如果 targetNode 是 parent 的右子结点

parent.right = targetNode.right

**情况三 ： 删除有两颗子树的节点. (比如：7, 3，10 )**

思路

(1) 需求先去找到要删除的结点 targetNode

(2) 找到targetNode 的 父结点 parent 

(3) 从targetNode 的右子树找到最小的结点

(4) 用一个临时变量，将 最小结点的值保存 temp = 11

(5) 删除该最小结点

(6) targetNode.value = temp

```java

public class BinarySearchTree {

    // 1、定义Node节点
    class Node {
        int value;
        Node left;
        Node right;

        public Node(int value) {
            this.value = value;
        }

        @Override
        public String toString() {
            return "Node{" +
                    "value=" + value +
                    '}';
        }

        /**
         * 添加节点方法
         *
         * @param node 待加入的节点
         */
        public void add(Node node) {
            //若待添加节点为空，直接返回
            if (node == null) {
                return;
            }
            //若待添加的节点值小于当前节点值，向左子树添加
            if (node.value < this.value) {
                if (this.left == null) {
                    this.left = node;
                } else {
                    this.left.add(node); //左子节点递归添加
                }
                // 若待添加的节点值大于等于当前节点，向右子树添加
            } else {
                if (this.right == null) {
                    this.right = node;
                } else {
                    this.right.add(node);
                }
            }
        }

        /**
         * 中序遍历
         */
        public void infixOrder() {
            if (this.left != null) {
                this.left.infixOrder();
            }
            System.out.println(this);
            if (this.right != null) {
                this.right.infixOrder();
            }
        }

        /**
         * 查找目标节点
         *
         * @param node 待查找的节点
         * @return 若未找到返回null, 若找到返回该节点
         */
        public Node search(Node node) {
            // 若为空就返回
            if (node == null) {
                return null;
            }
            if (node.value == this.value) {
                return this;
            } else if (node.value < this.value) {
                if (this.left == null) {
                    return null;
                }
                return this.left.search(node);
            } else {
                if (this.right == null) {
                    return null;
                }
                return this.right.search(node);
            }
        }

        /**
         * 查找目标节点的父节点
         *
         * @param node 目标节点
         * @return 找到则返回目标节点父节点；未找到则返回null
         */
        public Node searchParent(Node node) {
            if ((this.left != null && this.left.value == node.value) ||
                    (this.right != null && this.right.value == node.value)) {
                return this;
            } else {
                if (node.value < this.value && this.left != null) {
                    return this.left.searchParent(node);
                } else if (node.value >= this.value && this.right != null) {
                    return this.right.searchParent(node);
                } else {
                    return null;// 没有父节点
                }
            }
        }


    }

    //2、创建二叉排序树
    class BinarySerTree {
        private Node root;

        public BinarySerTree() {
        }

        public BinarySerTree(Node root) {
            this.root = root;
        }

        //添加节点
        public void add(Node node) {
            if (root == null) {
                root = node;
            } else {
                root.add(node);
            }
        }

        /**
         * 中序遍历
         */
        public void infixOrder() {
            if (root != null) {
                root.infixOrder();
            } else {
                System.out.println("树为空");
            }
        }

        /**
         * 查找目标节点
         *
         * @param node 待查节点
         * @return 找到返回该节点，没找到返回 null
         */
        public Node search(Node node) {
            if (root == null) {
                return null;
            } else {
                return root.search(node);
            }
        }

        /**
         * 查找目标节点的父节点
         *
         * @param node 目标节点
         * @return 查到了但会目标节点的父节点，没查到返回null
         */
        public Node searchParent(Node node) {
            if (root == null) {
                return null;
            } else {
                return root.searchParent(node);
            }
        }

        /**
         * 找右子树最小节点
         *
         * @param node 传入节点
         * @return 返回的是以Node为根节点的二叉树的最小的值
         */
        public int delRightTreeMin(Node node) {
            Node tar = node;
            while (tar.left != null) {
                tar = tar.left;
            }
            delNode(tar);
            return tar.value;
        }

        /**
         * 删除节点
         *
         * @param node
         */
        public void delNode(Node node) {
            if (root == null) {
                return;
            } else {
                Node targetNode = search(node);
                Node targetParent = searchParent(node);
                if (targetNode == null) {
                    return;
                }

                //若二叉树只有一个节点，并且该节点是目标节点
                if (root.left == null && root.right == null) {
                    root = null;
                    return;
                }

                //1、若删除的节点是叶子节点
                if (targetNode.left == null && targetNode.right == null) {
                    //判断targetnode 是parent的什么节点？
                    if (targetParent.left != null && targetParent.left.value == targetNode.value) {
                        targetParent.left = null;
                    } else if (targetParent.right != null && targetParent.right.value != targetNode.value) {
                        targetParent.right = null;
                    }

                    //2、目标节点有左右子树；
                } else if (targetNode.left != null && targetNode.right != null) {
                    int minVal = delRightTreeMin(targetNode.right);
                    targetNode.value = minVal;

                } else {
                    //3、删除只有一颗子树的节点
                    //待删除节点为左子节点
                    if (targetNode.left != null) {
                        if (targetParent != null) {
                            if (targetParent.left.value == node.value) {
                                targetParent.left = targetNode.left;
                            } else {
                                targetParent.right = targetNode.left;
                            }
                        } else {
                            root = targetNode.left;
                        }
                    } else {//待删除的节点为右子节点
                        if (targetParent != null) {
                            if (targetParent.left.value == node.value) {
                                targetParent.left = targetNode.right;
                            } else {
                                targetParent.right = targetNode.right;
                            }
                        }else{
                            root=targetNode.right;
                        }
                    }

                }
            }
        }

    }

    //3、测试
    @Test
    public void test() {
        int[] arr = {7, 3, 10, 12, 5, 1, 9, 2};
        BinarySerTree binarySerTree = new BinarySerTree();

        for (int i = 0; i < arr.length; i++) {
            binarySerTree.add(new Node(arr[i]));
        }
        binarySerTree.infixOrder();

        System.out.println("------------------");
        binarySerTree.delNode(new Node(12));

        binarySerTree.infixOrder();
    }

}
```

## 14、平衡二叉树

**问题：给一个已经排序好的数列{1、2、3、4、5、6}要求创建一个二叉排序树；**

**左边****BST** **存在的问题分析**:

1)左子树全部为空，从形式上看，更像一个单链表.

2)插入速度没有影响

3)查询速度明显降低(因为需要依次比较), 不能发挥BST
 的优势，因为每次还需要比较左子树，其查询速度比
 单链表还慢

4)解决方案-平衡二叉树(AVL)

![image-20201219104649054](/Users/anner/Library/Application Support/typora-user-images/image-20201219104649054.png)



具有以下**特点**：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有[红黑树](https://baike.baidu.com/item/红黑树/2413209)、[AVL](https://baike.baidu.com/item/AVL/7543015)、[替罪羊树](https://baike.baidu.com/item/替罪羊树/13859070)、[Treap](https://baike.baidu.com/item/Treap)、[伸展树](https://baike.baidu.com/item/伸展树/7003945)等



**左旋转：（思路）**

![image-20201219112247310](/Users/anner/Library/Application Support/typora-user-images/image-20201219112247310.png)





右旋转：

![image-20201219155703421](/Users/anner/Library/Application Support/typora-user-images/image-20201219155703421.png)



双旋转：

![image-20201219153701577](/Users/anner/Library/Application Support/typora-user-images/image-20201219153701577.png)

1、当符合右旋转的条件是

2、他左子树的右子树高度大于他左子树的左子树高度；

3、先对档案节点的左己诶单进行左旋转；

4、在对当前节点进行右旋转操作即可；

![image-20201219155629076](/Users/anner/Library/Application Support/typora-user-images/image-20201219155629076.png)

```java
class AVLTree {
    private Node root;

    public Node getRoot() {
        return root;
    }

    public Node search(int value) {
        if (root == null) {
            return null;
        } else {
            return root.search(value);
        }
    }

    public Node searchParent(int value) {
        if (root == null) {
            return null;
        } else {
            return root.searchParent(value);
        }
    }

    public int delRightTreeMin(Node node) {
        Node target = node;
        while (target.left != null) {
            target = target.left;
        }
        delNode(target.value);
        return target.value;
    }

    public void delNode(int value) {
        if (root == null) {
            return;
        } else {
            Node targetNode = search(value);
            if (targetNode == null) {
                return;
            }
            if (root.left == null && root.right == null) {
                root = null;
                return;
            }

            Node parent = searchParent(value);
            if (targetNode.left == null && targetNode.right == null) {
                if (parent.left != null && parent.left.value == value) {
                    parent.left = null;
                } else if (parent.right != null && parent.right.value == value) {
                    parent.right = null;
                }
            } else if (targetNode.left != null && targetNode.right != null) {
                int minVal = delRightTreeMin(targetNode.right);
                targetNode.value = minVal;

            } else {
                if (targetNode.left != null) {
                    if (parent != null) {
                        if (parent.left.value == value) {
                            parent.left = targetNode.left;
                            parent.right = targetNode.left;
                        }
                    } else {
                        root = targetNode.left;
                    }
                } else {
                    if (parent != null) {
                        if (parent.left.value == value) {
                            parent.left = targetNode.right;
                        } else { // Èç¹û targetNode ÊÇ parent µÄÓÒ×Ó½áµã
                            parent.right = targetNode.right;
                        }
                    } else {
                        root = targetNode.right;
                    }
                }

            }

        }
    }

    public void add(Node node) {
        if (root == null) {
            root = node;
        } else {
            root.add(node);
        }
    }

    public void infixOrder() {
        if (root != null) {
            root.infixOrder();
        } else {
            System.out.println("¶þ²æÅÅÐòÊ÷Îª¿Õ£¬²»ÄÜ±éÀú");
        }
    }
}

class Node {
    int value;
    Node left;
    Node right;

    public Node(int value) {

        this.value = value;
    }

    /**
     * @return返回左子树高度
     */
    public int leftHeight() {
        if (left == null) {
            return 0;
        }
        return left.height();
    }

    /**
     * @return 返回右子树高度
     */
    public int rightHeight() {
        if (right == null) {
            return 0;
        }
        return right.height();
    }

    /**
     * 返回树的高度
     *
     * @return 返回以该节点为根节点树的高度
     */
    public int height() {
        return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1;
    }

    /**
     * 左旋转
     */
    private void leftRotate() {
        //1、创建新节点，值为当前节点的值
        Node newNode = new Node(value);
        //2、把新节点设置为当前节点的左子树
        newNode.left = left;
        //3、把新节点的右子树设置成当前节点的右子树的左子树
        newNode.right = right.left;
        //4、把当前节点的值替换成嘴子节点的值
        value = right.value;
        // 5、把当前节点的右子树设置成当前姐弟昂右子树的右子树；
        right = right.right;
        //6、把新节点作为当前节点的坐姿节点
        left = newNode;
    }


    /**
     * 右旋转
     */
    private void rightRotate() {
        // 1、创建一个新节点
        Node newNode = new Node(value);
        newNode.right = right;
        newNode.left = left.right;
        value = left.value;
        left = left.left;
        right = newNode;
    }


    public Node search(int value) {
        if (value == this.value) {
            return this;
        } else if (value < this.value) {
            if (this.left == null) {
                return null;
            }
            return this.left.search(value);
        } else {
            if (this.right == null) {
                return null;
            }
            return this.right.search(value);
        }

    }


    public Node searchParent(int value) {

        if ((this.left != null && this.left.value == value) || (this.right != null && this.right.value == value)) {
            return this;
        } else {

            if (value < this.value && this.left != null) {
                return this.left.searchParent(value);
            } else if (value >= this.value && this.right != null) {
                return this.right.searchParent(value);
            } else {
                return null;
            }
        }

    }

    @Override
    public String toString() {
        return "Node [value=" + value + "]";
    }


    /**
     * 添加节点
     *
     * @param node
     */
    public void add(Node node) {
        if (node == null) {
            return;
        }

        if (node.value < this.value) {
            if (this.left == null) {
                this.left = node;
            } else {
                this.left.add(node);
            }
        } else {
            if (this.right == null) {
                this.right = node;
            } else {
                this.right.add(node);
            }

        }

        // 右子树的的高度大于左子树的高度，左旋转
        if (rightHeight() - leftHeight() > 1) {
            //若它的右子树的左子树的高度大于它右子树的右子树的高度
            if (right != null && right.leftHeight() > right.rightHeight()) {
                // 右子节点进行右旋操作
                right.rightRotate();
                //当前节点进行左旋操作
                leftRotate();
            } else {
                leftRotate();
            }
            return;
        }

        //左子树的高度大于右子树的高度，右旋转
        if (leftHeight() - rightHeight() > 1) {
            //若他左子树的右子树高度大于他左子树的左子树高度；
            if (left != null && left.rightHeight() > left.leftHeight()) {
                
                left.leftRotate();

                rightRotate();
            } else {

                rightRotate();
            }
        }
    }

    // 中序遍历
    public void infixOrder() {
        if (this.left != null) {
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right != null) {
            this.right.infixOrder();
        }
    }

}
```

## 15、多叉树

二叉树的操作效率较高，但是也存在问题,：

1)**二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如1亿)， 就存在如下问题:

2)问题1：在构建二叉树时，需要多次进行i/o操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时，速度有影响

3)问题2：节点海量，也会造成二叉树的高度很大，会降低操作速度；



![image-20201222103024129](/Users/anner/Library/Application Support/typora-user-images/image-20201222103024129.png)

B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率。

1)如图B树通过重新组织节点， 降低了树的高度.

2)**文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页**(页得大小通常为4k**)，这样每个节点只需要一次I/O就可以完全载入

3)将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素, B树(B+)广泛应用于文件存储系统以及数据库系统中

