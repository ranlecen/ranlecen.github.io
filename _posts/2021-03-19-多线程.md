#  多线程

一、谈谈对程序，进程，线程的理解

**程序**：静态的，用某种语言编写的，一组指令的集合；静态的代码块；

进程：程序的一次执行，是一个正在运行的程序；是资源分配的单位； 声明周期；

线程：进程的进一步细化，是一个程序内部的一条执行路径； 状态转换



**二、代码实现 继承Thread. 或者 实现Runable 接口**

1、 继承一个Thread 子类，重写run方法，创建Thread对象，通过对象调用 start（） 方法，

线程的启动，是通过start（） 方法，而不是通过调用 线程的run方法；



2、方式二：实现Runnable接口的方式：

 创建一个实现了Runnable接口的类; 实现类去实现Runnable中的抽象方法：run();创建实现类的对象; 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象;通过Thread类的对象调用start()*



两种实现方式的对比：

1、开发中优先选择runable接口的方式；

2、实现的方式，没有类的单继承的局限性；

3、 实现的方式更适合来处理多个线程共享数据的情况；

4、两者的联系，其实Thread 类，源码也是实现runable接口；

5、无论是继承Thread还是实现runable 接口，都需要重写 run() 方法；



三、单核CPU与多核CPU的理解

- ·	单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费。）但是因为CPU时间单元特别短，因此感觉不出来。
- ·	如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）

- ·	一个Java应用程序java.exe，其实至少三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。

四、并行与并发的理解

- ·	**并行：**多个CPU同时执行多个任务。比如：多个人同时做不同的事。

- ·	**并发：**一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事



**五、 Thread类中的常用的方法:**

start():启动当前线程；调用当前线程的run()
 \* 2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中
 \* 3. currentThread():静态方法，返回执行当前代码的线程
 \* 4. getName():获取当前线程的名字
 \* 5. setName():设置当前线程的名字
 \* 6. yield():释放当前cpu的执行权
 \* 7. join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。
 \* 8. stop():已过时。当执行此方法时，强制结束当前线程。
 \* 9. sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。
 \* 10. isAlive():判断当前线程是否存活



线程的优先级：
 \* MAX_PRIORITY：10
 \* MIN _PRIORITY：1
 \* NORM_PRIORITY：5 -->默认优先级
 \* 2.如何获取和设置当前线程的优先级：
 \*  getPriority():获取线程的优先级
 \*  setPriority(int p):设置线程的优先级
 \*
 说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。

*线程通信：wait() / notify() / notifyAll() :并不是定义在 Thread类中，此三个方法定义在Object类中的。*



线程分类：

一种是**守护线程**，一种是**用户线程**