# Mybatis

## 一、Mybatis 初体验

### 1.1 Mybatis 简介

​	**mybatis** 是一款同数据库打交到的ORM （Object Relation Mapping）框架，采用；是对原来的 JDBC，DBUtil，jdbcTemplate 的丰富；

![image-20210119104433413](/Users/anner/Library/Application Support/typora-user-images/image-20210119104433413.png)

**Hibernate：**全自动全映射ORM（Object Relation Mapping）框架；旨在消除sql，**HQL**

![image-20210119104619162](/Users/anner/Library/Application Support/typora-user-images/image-20210119104619162.png)

但是由于，SQL语句，大多无法定制化，HQL，增加了学习难度；希望：sql语句交给我们开发人员编写，希望sql不失去灵活性；

**Mybatis：**是一款半自动，请谅解的框架，Sql与java编码分离，将sql语句以配置文件的方式传入；sql是开发人员控制

![image-20210119104830437](/Users/anner/Library/Application Support/typora-user-images/image-20210119104830437.png)

### 1.2 Mybatis - Helloword

**第一步：引入相应依赖**

```xml
<!--        mybatis  jar包-->
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.3.0</version>
</dependency>
<!-- mysql驱动包 -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.22</version>
</dependency>

<!--log4j-->
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-api</artifactId>
    <version>2.14.0</version>
</dependency>
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>2.14.0</version>
</dependency>

<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.11</version>
    <scope>test</scope>
</dependency>
```

**第二步：类& 表的创建**

```java
public class Employee {
    private Integer id;
    private String lastName;
    private String email;
    private String gender;

    public Employee(String lastName, String email, String gender) {
        this.lastName = lastName;
        this.email = email;
        this.gender = gender;
    }

    public Employee() {
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "id=" + id +
                ", lastName='" + lastName + '\'' +
                ", email='" + email + '\'' +
                ", gender='" + gender + '\'' +
                '}';
    }
}
```

```sql
create table tbl_employee
(
    id        int auto_increment
        primary key,
    last_name varchar(25)  null,
    gender    char         null,
    email     varchar(255) null
);
```

注意：表字段与类属性的相互对应；

**第三步：mybatis 的相关配置**

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://192.168.234.7:3306/userDb?useSSL=true&amp;useUnicode=true&amp;"/>
                <property name="username" value="root"/>
                <property name="password" value="root"/>
            </dataSource>
        </environment>
    </environments>
   <!-- 将我们写好的sql映射文件（EmployeeMapper.xml）一定要注册到全局配置文件（mybatis-config.xml）中 -->
    <mappers>
        <mapper resource="EmployeeMapper.xml"/>
    </mappers>
</configuration>
```

**第四步： mapper&& intyerface DAO** 

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
 "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.restart.dao.EmployeeMapper">
<!-- 
namespace:名称空间;指定为接口的全类名
id：唯一标识
resultType：返回值类型
#{id}：从传递过来的参数中取出id值

public Employee getEmpById(Integer id);
 -->
   <select id="getEmpById" resultType="com.restart.bean.Employee">
      select id,last_name lastName,email,gender from tbl_employee where id = #{id}
   </select>
</mapper>
```

```java
public interface EmployeeMapper {

    public Employee getEmpById(Integer id);
}
```

**第五步：TEST**

```java
/**
 * 1、接口式编程
 * 	原生：		Dao		====>  DaoImpl
 * 	mybatis：	Mapper	====>  xxMapper.xml
 * 
 * 2、SqlSession代表和数据库的一次会话；用完必须关闭；
 * 3、SqlSession和connection一样都是非线程安全。每次使用都应该去获取新的对象。
 * 4、mapper接口没有实现类，但是mybatis会为这个接口生成一个代理对象。
 * 		（将接口和xml进行绑定）
 * 		EmployeeMapper empMapper =	sqlSession.getMapper(EmployeeMapper.class);
 * 5、两个重要的配置文件：
 * 		mybatis的全局配置文件：包含数据库连接池信息，事务管理器信息等...系统运行环境信息
 * 		sql映射文件：保存了每一个sql语句的映射信息：
 * 					将sql抽取出来。	
 * 
 */
 
public class Test {

    public SqlSessionFactory getSqlSessionFactory() throws IOException {
        String resource = "mybatis-config.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        return new SqlSessionFactoryBuilder().build(inputStream);
    }


    @org.junit.Test
    public void test02() throws IOException {
        // 1、获取sqlSessionFactory对象
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
        // 2、获取sqlSession对象
        SqlSession openSession = sqlSessionFactory.openSession();
        try {
            // 3、获取接口的实现类对象
            //会为接口自动的创建一个代理对象，代理对象去执行增删改查方法
            EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);
            Employee employee = mapper.getEmpById(1);
            System.out.println(mapper.getClass());
            System.out.println(employee);
        } finally {
            openSession.close();
        }
    }

    /**
     * 1、根据xml配置文件（全局配置文件）创建一个SqlSessionFactory对象 有数据源一些运行环境信息
     * 2、sql映射文件；配置了每一个sql，以及sql的封装规则等。
     * 3、将sql映射文件注册在全局配置文件中
     * 4、写代码：
     *        1）、根据全局配置文件得到SqlSessionFactory；
     *        2）、使用sqlSession工厂，获取到sqlSession对象使用他来执行增删改查
     *           一个sqlSession就是代表和数据库的一次会话，用完关闭
     *        3）、使用sql的唯一标志来告诉MyBatis执行哪个sql。sql都是保存在sql映射文件中的。
     */
    @org.junit.Test
    public void test01() throws Exception {
        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();

        SqlSession openSession = sqlSessionFactory.openSession();
        // 2、获取SQLsession实例，执行已经映射的sql语句
        // sql的唯一标识：statement Unique identifier matching the statement to use.
        // 执行sql要用的参数：parameter A parameter object to pass to the statement.

        try {

            Employee tom = openSession.selectOne("com.restart.EmployeeMapper.selectEmp", 1);
            System.out.println(tom);
        }finally {

            openSession.close();
        }

    }
}
```

## 二、mybatis 全局配置文件



```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!--
    Properties 属性
        1、mybatis可以使用properties来引入外部properties配置文件的内容；
      resource：引入类路径下的资源
      url：引入网络路径或者磁盘路径下的资源
      2、以下是引入 数据库配置文件
    -->
    <properties resource="dbconfig.properties"></properties>

    <!--
      2、settings包含很多重要的设置项
      setting:用来设置每一个设置项
          name：设置项名
          value：设置项取值
      -->
    <settings>
        <setting name="mapUnderscoreToCamelCase" value="true"/>
    </settings>

    <!-- 3、typeAliases：别名处理器：可以为我们的java类型起别名
        别名不区分大小写
       -->
    <typeAliases>
        <!-- 1、typeAlias:为某个java类型起别名
                type:指定要起别名的类型全类名;默认别名就是类名小写；employee
                alias:指定新的别名
         -->
        <!-- <typeAlias type="com.atguigu.mybatis.bean.Employee" alias="emp"/> -->

        <!-- 2、package:为某个包下的所有类批量起别名
                name：指定包名（为当前包以及下面所有的后代包的每一个类都起一个默认别名（类名小写），）
        -->
        <package name="com.atguigu.mybatis.bean"/>

        <!-- 3、批量起别名的情况下，使用@Alias注解为某个类型指定新的别名 -->
    </typeAliases>

    <!--
      4、environments：环境们，mybatis可以配置多种环境 ,default指定使用某种环境。可以达到快速切换环境。
         environment：配置一个具体的环境信息；必须有两个标签；id代表当前环境的唯一标识
            transactionManager：事务管理器；
               type：事务管理器的类型;JDBC(JdbcTransactionFactory)|MANAGED(ManagedTransactionFactory)
                  自定义事务管理器：实现TransactionFactory接口.type指定为全类名

            dataSource：数据源;
               type:数据源类型;UNPOOLED(UnpooledDataSourceFactory)
                        |POOLED(PooledDataSourceFactory)
                        |JNDI(JndiDataSourceFactory)
               自定义数据源：实现DataSourceFactory接口，type是全类名
       -->

    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url"
                          value="${jdbc.url}?useSSL=true&amp;useUnicode=true&amp;"/>
                <property name="username" value="${jdbc.username}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>

        <environment id="dev_oracle">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="${orcl.driver}"/>
                <property name="url" value="${orcl.url}"/>
                <property name="username" value="${orcl.username}"/>
                <property name="password" value="${orcl.password}"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 5、databaseIdProvider：支持多数据库厂商的；
       type="DB_VENDOR"：VendorDatabaseIdProvider
         作用就是得到数据库厂商的标识(驱动getDatabaseProductName())，mybatis就能根据数据库厂商标识来执行不同的sql;
         MySQL，Oracle，SQL Server,xxxx
     -->
    <databaseIdProvider type="DB_VENDOR">
        <!-- 为不同的数据库厂商起别名 -->
        <property name="MySQL" value="mysql"/>
        <property name="Oracle" value="oracle"/>
        <property name="SQL Server" value="sqlserver"/>
    </databaseIdProvider>

    <!-- 将我们写好的sql映射文件（EmployeeMapper.xml）一定要注册到全局配置文件（mybatis-config.xml）中 -->
    <mappers>
        <!--
         mapper:注册一个sql映射
            注册配置文件
            resource：引用类路径下的sql映射文件
               mybatis/mapper/EmployeeMapper.xml
            url：引用网路路径或者磁盘路径下的sql映射文件
               file:///var/mappers/AuthorMapper.xml

            注册接口
            class：引用（注册）接口，
               1、有sql映射文件，映射文件名必须和接口同名，并且放在与接口同一目录下；
               2、没有sql映射文件，所有的sql都是利用注解写在接口上;
               推荐：
                  比较重要的，复杂的Dao接口我们来写sql映射文件
                  不重要，简单的Dao接口为了开发快速可以使用注解；
      -->
        <!-- <mapper resource="mybatis/mapper/EmployeeMapper.xml"/> -->
        <!-- <mapper class="com.atguigu.mybatis.dao.EmployeeMapperAnnotation"/> -->

        <!-- 批量注册： -->
        <mapper resource="EmployeeMapper.xml"/>
        <mapper class="com.restart.dao.EmployeeMapperAnnotation"/>
    </mappers>
</configuration>
```

## 三、Mybatis 映射文件

### 3.1 增删改查

**第一步 ：声明相关接口** 

```java
// 方式一： 直接在接口上  写明 sql语句
public interface EmployeeMapperAnnotation {
    @Select("select * from tbl_employee where id=#{id}")
    public Employee getEmpById(Integer id);

    @Insert("insert into tbl_employee(last_name,email,gender) values (#{lastName},#{email},#{gender})")
    public void addEmp(Employee employee);

    @Update("update tbl_employee\n" +
            "\t\t\tset last_name=#{lastName},email=#{email},gender=#{gender}\n" +
            "\t\t\twhere id=#{id}")
    public void updateEmp(Employee employee);

    @Delete("delete from tbl_emplo yee where id=#{id}")
    public void deleteEmpById(Integer id);
}
```

```xml
<!-- 方法二：sql语句抽离到 xml文件中-->

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
 "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.restart.dao.EmployeeMapper">
<!-- 
namespace:名称空间;指定为接口的全类名
id：唯一标识
resultType：返回值类型
#{id}：从传递过来的参数中取出id值

public Employee getEmpById(Integer id);
 -->
   <select id="getEmpById" resultType="com.restart.bean.Employee" databaseId="mysql">
      select id,last_name lastName,email,gender from tbl_employee where id = #{id}
   </select>

   <!--useGeneratedKeys="true" keyProperty="id" 调用自增主键，并且指明主键 -->
   <insert id="addEmp" parameterType="com.restart.bean.Employee" databaseId="mysql" 
         useGeneratedKeys="true" keyProperty="id">
      insert into tbl_employee(last_name,email,gender) values (#{lastName},#{email},#{gender})
   </insert>
   
   <update id="updateEmp" >
      update tbl_employee
         set last_name=#{lastName},email=#{email},gender=#{gender}
         where id=#{id}
   </update>

   <delete id="deleteEmpById">
      delete from tbl_employee where id=#{id}
   </delete>
</mapper>
```



**第二步:测试**

```java
@org.junit.Test
public void testDelete() throws IOException {
    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
    SqlSession openSession = sqlSessionFactory.openSession(true);  // 自动提交
    try {

        EmployeeMapperAnnotation mapper = openSession.getMapper(EmployeeMapperAnnotation.class);
        mapper.deleteEmpById(1);
    } finally {
        openSession.close();
    }
}


@org.junit.Test
public void testupdate() throws IOException {
    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
    SqlSession openSession = sqlSessionFactory.openSession(true);
    try {

        EmployeeMapperAnnotation mapper = openSession.getMapper(EmployeeMapperAnnotation.class);

        Employee Jary = new Employee(1,"Jary", "jary@gmail.com", "1");

        mapper.updateEmp(Jary);

    } finally {
        System.out.println(111);
        openSession.close();
    }
}

@org.junit.Test
public void testInsert() throws IOException {
    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
    SqlSession openSession = sqlSessionFactory.openSession(true);
    try {

        EmployeeMapperAnnotation mapper = openSession.getMapper(EmployeeMapperAnnotation.class);

        Employee jary = new Employee(null,"Ray", "Ray@gmail.com", "0");

        mapper.addEmp(jary);
    } finally {
        System.out.println(111);
        openSession.close();
    }
}
```

### 3.2 Mybatis  参数处理

**单个参数：**mybatis不会做特殊处理，
	#{参数名/任意名}：取出参数值。

**多个参数**：mybatis会做特殊处理。
	多个参数会被封装成 一个map，
		key：param1...paramN,**或者参数的索引也可以**
		value：传入的参数值
	#{}就是从map中获取指定的key的值；
	

```java
异常：
org.apache.ibatis.binding.BindingException: 
Parameter 'id' not found. 
Available parameters are [1, 0, param1, param2]
操作：
	方法：public Employee getEmpByIdAndLastName(Integer id,String lastName);
	取值：#{id},#{lastName}
```

【命名参数】：明确指定封装参数时map的key；@Param("id")
	多个参数会被封装成 一个map，
		key：使用@Param注解指定的值
		value：参数值
	#{指定的key}取出对应的参数值

```java
public interface EmployeeMapper {

    public Employee getEmpById(@Param("id") Integer id, @Param("lastname") String lastName);
}
```

**POJO：**
如果多个参数正好是我们业务逻辑的数据模型，我们就可以直接传入pojo；
	#{属性名}：取出传入的pojo的属性值	

**Map：**
如果多个参数不是业务模型中的数据，没有对应的pojo，不经常使用，为了方便，我们也可以传入map
	#{key}：取出map中对应的值;

**TO：**
如果多个参数不是业务模型中的数据，但是经常要使用，推荐来编写一个TO（Transfer Object）数据传输对象
Page{
	int index;
	int size;
}

#### 思考

```java
//========================思考================================	
public Employee getEmp(@Param("id")Integer id,String lastName);
	//取值：id==>#{id/param1}   lastName==>#{param2}

public Employee getEmp(Integer id,@Param("e")Employee emp);
	//取值：id==>#{param1}    lastName===>#{param2.lastName/e.lastName}

/**##特别注意：如果是Collection（List、Set）类型或者是数组，
		 也会特殊处理。也是把传入的list或者数组封装在map中。
			key：Collection（collection）,如果是List还可以使用这个key(list)
				数组(array)
*/
public Employee getEmpById(List<Integer> ids);
//	取值：取出第一个id的值：   #{list[0]}


```

### 3.3 参数值的获取

#{}：可以获取map中的值或者pojo对象属性的值；
${}：可以获取map中的值或者pojo对象属性的值；

```java
select * from tbl_employee where id=${id} and last_name=#{lastName}
Preparing: select * from tbl_employee where id=2 and last_name=?
区别：
	#{}:是以预编译的形式，将参数设置到sql语句中；PreparedStatement；防止sql注入
	${}:取出的值直接拼装在sql语句中；会有安全问题；
	大多情况下，我们去参数的值都应该去使用#{}；
  
原生jdbc不支持占位符的地方我们就可以使用${}进行取值
比如分表、排序。。。；按照年份分表拆分
	select * from ${year}_salary where xxx;
	select * from tbl_employee order by ${f_name} ${order}
```



```java
#{}:更丰富的用法：
	规定参数的一些规则：
	javaType、 jdbcType、 mode（存储过程）、 numericScale、
	resultMap、 typeHandler、 jdbcTypeName、 expression（未来准备支持的功能）；

	jdbcType通常需要在某种特定的条件下被设置：
		在我们数据为null的时候，有些数据库可能不能识别mybatis对null的默认处理。比如Oracle（报错）；
		
		JdbcType OTHER：无效的类型；因为mybatis对所有的null都映射的是原生Jdbc的OTHER类型，oracle不能正确处理;
		
		由于全局配置中：jdbcTypeForNull=OTHER；oracle不支持；两种办法
		1、#{email,jdbcType=OTHER};
		2、jdbcTypeForNull=NULL
			<setting name="jdbcTypeForNull" value="NULL"/>


```

## 四、Mapper.xml Result MAP 相关设置

### 4.1 返回结果处理

**返回结果为list&&map:**

```java
public interface EmployeeMapper {

    // 返回值，一条基于是map，key就是列名
    public Map<String, Object> getEmpByIdReturenMap(Integer id);

    public List<Employee> getEmpByLastName(@Param("lastName") String lastName);
}
```

```xml
   <!-- 返回为MAP  -->
<select id="getEmpByIdReturenMap" resultType="map" databaseId="mysql">
   select id,last_name,email,gender from tbl_employee where id = #{id}
</select>

   <!--public List<Employee> getEmpByLastName(@Param("lastName")String lastName);
   resultType 就是其返回值元素的类型
   -->
<select id="getEmpByLastName" resultType="com.restart.bean.Employee" databaseId="mysql">
   select id,last_name,email,gender from tbl_employee where last_name = #{lastName}
</select>
```

### 4.2. ResultMap

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.restart.dao.EmployeeMapperPlus">
    <!--
    ResultMap自定义返回类型：
    id: s是唯一标识别
    type： 是返回值类型
    -->
    <resultMap id="MyEmp" type="com.restart.bean.Employee">
        <!-- 指定主键列的封装规则：
               id定义主键底层有优化
               column  指定表中的字段
               property 指定对应的JavaBean 属性-->
        <id column="id" property="id"/>
        <result column="last_name" property="lastName"/>
        <result column="email" property="email"/>
        <result column="gender" property="gender"/>
    </resultMap>

    <!--    <select id="getEmpById" resultType="com.restart.bean.Employee">-->
    <!--        select * from tbl_employee where id=#{id}-->
    <!--    </select>-->

    <select id="getEmpById" resultMap="MyEmp">
        select * from tbl_employee where id=#{id}
    </select>

</mapper>
```

### 4.3 表中有级联属性（resultMap-association）

```xml
   <!--
场景一：
   查询Employee的同时查询员工对应的部门
   Employee===Department
   一个员工有与之对应的部门信息；
   id  last_name  gender    d_id     did  dept_name (private Department dept;)
       联合查询：级联属性封装结果集
     -->
   <resultMap id="myEmpPlus" type="com.restart.bean.Employee">
       <id column="id" property="id"/>
       <result column="last_name" property="lastName"/>
       <result column="gender" property="gender"/>
       <result column="did" property="dept.id"/>
       <result column="dept_name" property="dept.departmerntName"/>
   </resultMap>

   <!--
   使用association定义关联的单个对象的封装规则；
 -->
   <resultMap type="com.restart.bean.Employee" id="myEmpPlus2">
       <id column="id" property="id"/>
       <result column="last_name" property="lastName"/>
       <result column="gender" property="gender"/>

       <!--  association可以指定联合的javaBean对象
       property="dept"：指定哪个属性是联合的对象
       javaType:指定这个属性对象的类型[不能省略]
       -->
       <association property="dept" javaType="com.restart.bean.Department">
           <id column="did" property="id"/>
           <result column="dept_name" property="departmentName"/>
       </association>
   </resultMap>
   <select id="getEmpAndDept" resultMap="myEmpPlus2">
       SELECT e.id id,e.last_name last_name,e.gender gender,e.d_id d_id,
   d.id did,d.dept_name dept_name FROM tbl_employee e,tbl_dept d
   WHERE e.d_id=d.id AND e.id=#{id}
   </select>
```

### 4.4 使用Assocation  实现分步查询（resultMap-association）

```xml
<!-- 使用association进行分步查询：
	1、先按照员工id查询员工信息
	2、根据查询员工信息中的d_id值去部门表查出部门信息
	3、部门设置到员工中；
 -->
 
 <!--  id  last_name  email   gender    d_id   -->
 <resultMap type="com.atguigu.mybatis.bean.Employee" id="MyEmpByStep">
 	<id column="id" property="id"/>
 	<result column="last_name" property="lastName"/>
 	<result column="email" property="email"/>
 	<result column="gender" property="gender"/>
 	<!-- association定义关联对象的封装规则
 		select:表明当前属性是调用select指定的方法查出的结果
 		column:指定将哪一列的值传给这个方法
 		
 		流程：使用select指定的方法（传入column指定的这列参数的值）查出对象，并封装给property指定的属性
 	 -->
	<association property="dept" 
 		select="com.atguigu.mybatis.dao.DepartmentMapper.getDeptById"
 		column="d_id">
	</association>
 </resultMap>
 <!--  public Employee getEmpByIdStep(Integer id);-->
 <select id="getEmpByIdStep" resultMap="MyEmpByStep">
 	select * from tbl_employee where id=#{id}
 	<if test="_parameter!=null">
 		and 1=1
 	</if>
 </select>
```
### 4.5 定义关联属性集合类型的属性的封装规则（resultMap-Collection）

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.restart.dao.DepartmentMapper">

    <!--
   public class Department {
         private Integer id;
         private String departmentName;
         private List<Employee> emps;
     did  dept_name  ||  eid  last_name  email   gender
    -->

    <!--嵌套结果集的方式，使用collection标签定义关联的集合类型的属性封装规则  -->
    <resultMap id="getDeptlist" type="com.restart.bean.Department">
        <id column="did" property="id"/>
        <result column="dept_name" property="departmentName"/>
        <!--
             collectin 定义关联属性集合类型的属性的封装规则
             ofType:指定集合里面元素类型
             -->
        <collection property="emps" ofType="com.restart.bean.Employee">
            <!--            定义集合中元素的人封装规则-->
            <result column="last_name" property="lastName"/>
            <result column="email" property="email"/>
            <result column="gender" property="gender"/>
        </collection>
    </resultMap>

    <select id="getDeptByIdPlus" resultMap="getDeptlist">
        select d.id did,d.dept_name dept_name,
            e.id eid,e.last_name last_name, e.email email,e.gender gender
            from tbl_dept d
            left join tbl_employee e
            on d.id=e.d_id
            where d.id=#{id}
    </select>

</mapper>
```

###  4.6  分段查询（resultmap-select）

```xml

<!-- Departmentmapper.xml-->
<resultMap id="mydeptStep" type="com.restart.bean.Department">
    <id column="id" property="id"/>
    <id column="dept_name" property="departmentName"/>
    <collection property="emps"
                select="com.restart.dao.EmployeeMapperPlus.getEmpByDeptId" column="id">
    </collection>
</resultMap>
<!--     public Department getDeptByIdStep(Integer id);-->
<select id="getDeptByIdStep" resultMap="mydeptStep">
    select  id,dept_name departmentName from tbl_dept where id=#{id}
</select>

<!-- Empliyeemapper.xml-->
<!--    public List<Employee> getEmpByDeptId(Integer deptId);-->
<select id="getEmpByDeptId" resultType="com.restart.bean.Employee">
    select * from tbl_employee where d_id=#{deptId}
</select>

```

### 4.7discriminator （resultmap-discriminator） 鉴别器

```xml
<!--<discriminator javaType="string"   -->
 <!--
 鉴别器： 可以使用discriminator，判断某列的值，然后根据某列的值改变封装行为
 封装Employee：
如果查出的是女生：就把部门信息查询出来，否则不查询；
如果是男生，把last_name这一列的值赋值给email;
 -->
 <resultMap id="myEmpDis" type="com.restart.bean.Employee">
     <id column="id" property="id"/>
     <result column="last_name" property="lastName"/>
     <result column="email" property="email"/>
     <result column="gender" property="gender"/>

     <discriminator javaType="string" column="gender">
         <!--     女生
            resultType 指定封装结果的类型 ，不能少
            ！-->
         <case value="0" resultType="com.restart.bean.Employee">
             <association property="dept"
                          select="com.restart.dao.DepartmentMapper.getDeptByIdStep"
                          column="d_id"/>
         </case>
         <!--            男生-->
         <case value="1" resultType="com.restart.bean.Employee">
             <id column="id" property="id"/>
             <result column="last_name" property="lastName"/>
             <result column="last_name" property="email"/>
             <result column="gender" property="gender"/>
         </case>
     </discriminator>
 </resultMap>

 <select id="getEmpByDeptId" resultMap="myEmoDis">
     select * from tbl_employee where id=#{id}
 </select>
```

## 五、动态SQL

鉴于手写的SQL，度程序员不太友好，故，Mybatis 提供了动态SQL； **if、choose**

**Foreach、set、** 等关键字，用于SQL 语句的拼装；

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.restart.dao.EmployeeMapperDynamicSQL">

    <!-- if 标签，判断
    查询员工，要求，携带了哪个字段查询条件就带上这个字段的值
    public List<Employee> getEmpsByConditionIf(Employee employee);
    -->
    <select id="getEmpsByConditionIf" resultType="com.restart.bean.Employee">
        select * from tbl_employee
        <!-- where -->
        <where>
            <!-- test：判断表达式（OGNL）
            OGNL参照PPT或者官方文档。
                   c:if  test
            从参数中取值进行判断

            遇见特殊符号应该去写转义字符：
            &&：
            -->
            <if test="id!=null">
                id=#{id}
            </if>
            <if test="lastName!=null &amp;&amp; lastName!=&quot;&quot;">
                and last_name like #{lastName}
            </if>
            <if test="email!=null and email.trim()!=&quot;&quot;">
                and email=#{email}
            </if>
            <!-- ognl会进行字符串与数字的转换判断  "0"==0 -->
            <if test="gender==0 or gender==1">
                and gender=#{gender}
            </if>
        </where>
    </select>


    <!--    Trim 字符串截取（where）
    where 封装查询条件
    set 封装 修改条件
    -->
    <select id="getEmpsByConditionTrim" resultType="com.restart.bean.Employee">
        select * from tbl_employee
        <!-- 自定义字符串的截取规则
        后面多处 and or where 标签不能解决
        prefix="":前缀：trim标签体中是整个字符串拼串 后的结果。
            prefix给拼串后的整个字符串加一个前缀
      prefixOverrides="":
            前缀覆盖： 去掉整个字符串前面多余的字符
      suffix="":后缀
            suffix给拼串后的整个字符串加一个后缀
      suffixOverrides=""
            后缀覆盖：去掉整个字符串后面多余的字符
        -->
        <trim prefix="where" suffixOverrides="and">
            <if test="id!=null">
                id=#{id} and
            </if>
            <if test="lastName!=null &amp;&amp; lastName!=&quot;&quot;">
                last_name like #{lastName} and
            </if>
            <if test="email!=null and email.trim()!=&quot;&quot;">
                email=#{email} and
            </if>
            <!-- ognl会进行字符串与数字的转换判断  "0"==0 -->
            <if test="gender==0 or gender==1">
                gender=#{gender}
            </if>
        </trim>
    </select>

    <!--
    choose  分支选择
    需求：          如果带了id就用id查，如果带了lastName就用lastName查;只会进入其中
    public List<Employee> getEmpsByConditionChoose(Employee employee);
    -->
    <select id="getEmpsByConditionChoose" resultType="com.restart.bean.Employee">
        select * from tbl_employee
        <where>
            <choose>
                <when test="id!=null">
                    id=#{id}
                </when>
                <when test="lastName!=null">
                    last_name like #{lastName}
                </when>
                <when test="email!=null">
                    email = #{email}
                </when>
                <otherwise>
                    gender = 0
                </otherwise>
            </choose>
        </where>
    </select>

    <!--
    Update set 标签
    public void updateEmp(Employee employee);
    -->
    <update id="updateEmp">
        <!-- Set标签的使用 -->
        update tbl_employee
        <set>
            <if test="lastName!=null">
                last_name=#{lastName},
            </if>
            <if test="email!=null">
                email=#{email},
            </if>
            <if test="gender!=null">
                gender=#{gender}
            </if>
        </set>
    </update>

    <!--public List<Employee> getEmpsByConditionForeach(List<Integer> ids);  -->
    <select id="getEmpsByConditionForeach" resultType="com.restart.bean.Employee">
        select * from tbl_employee
        <!--
            collection：指定要遍历的集合：
                list类型的参数会特殊处理封装在map中，map的key就叫list
            item：将当前遍历出的元素赋值给指定的变量
            separator:每个元素之间的分隔符
            open：遍历出所有结果拼接一个开始的字符
            close:遍历出所有结果拼接一个结束的字符
            index:索引。遍历list的时候是index就是索引，item就是当前值
                          遍历map的时候index表示的就是map的key，item就是map的值

            #{变量名}就能取出变量的值也就是当前遍历出的元素
          -->
        <foreach collection="ids" item="item_id" separator=","
                 open="where id in(" close=")">
            #{item_id}
        </foreach>
    </select>

    <!-- 批量保存 -->
    <!--public void addEmps(@Param("emps")List<Employee> emps);  -->
    <!--MySQL下批量保存：可以foreach遍历   mysql支持values(),(),()语法-->
    <!-- 这种方式需要数据库连接属性allowMultiQueries=true；
      这种分号分隔多个sql可以用于其他的批量操作（删除，修改）-->
    <insert id="addEmps">
        insert into tbl_employee(
        <include refid="insertColumn"></include>
        )
        values
        <foreach collection="emps" item="emp" separator=",">
            (#{emp.lastName},#{emp.email},#{emp.gender},#{emp.dept.id})
        </foreach>
    </insert>

    <insert id="addEmpss">
        <foreach collection="emps" item="emp" separator=";">
            insert into tbl_employee(last_name,email,gender,d_id)
            values(#{emp.lastName},#{emp.email},#{emp.gender},#{emp.dept.id})
        </foreach>
    </insert>
  
  
  <!-- 两个内置参数：
	 	不只是方法传递过来的参数可以被用来判断，取值。。。
	 	mybatis默认还有两个内置参数：
	 	_parameter:代表整个参数
	 		单个参数：_parameter就是这个参数
	 		多个参数：参数会被封装为一个map；_parameter就是代表这个map
	 	
	 	_databaseId:如果配置了databaseIdProvider标签。
	 		_databaseId就是代表当前数据库的别名oracle
	  -->
	  
	  <!--public List<Employee> getEmpsTestInnerParameter(Employee employee);  -->
	  <select id="getEmpsTestInnerParameter" resultType="com.atguigu.mybatis.bean.Employee">
	  		<!-- bind：可以将OGNL表达式的值绑定到一个变量中，方便后来引用这个变量的值 -->
	  		<bind name="_lastName" value="'%'+lastName+'%'"/>
	  		<if test="_databaseId=='mysql'">
	  			select * from tbl_employee
	  			<if test="_parameter!=null">
	  				where last_name like #{lastName}
	  			</if>
	  		</if>
	  		<if test="_databaseId=='oracle'">
	  			select * from employees
	  			<if test="_parameter!=null">
	  				where last_name like #{_parameter.lastName}
	  			</if>
	  		</if>
	  </select>
	  
	  <!-- 
	  	抽取可重用的sql片段。方便后面引用 
	  	1、sql抽取：经常将要查询的列名，或者插入用的列名抽取出来方便引用
	  	2、include来引用已经抽取的sql：
	  	3、include还可以自定义一些property，sql标签内部就能使用自定义的属性
	  			include-property：取值的正确方式${prop},
	  			#{不能使用这种方式}
	  -->
	  <sql id="insertColumn">
	  		<if test="_databaseId=='oracle'">
	  			employee_id,last_name,email
	  		</if>
	  		<if test="_databaseId=='mysql'">
	  			last_name,email,gender,d_id
	  		</if>
	  </sql>

</mapper>
```



## 六、MyBatis 缓存机制

缓存的作用提高运行速度，及查询效率；Mybatis 可以非常方便的配置和定制，缓存可以极大的题啊高查询效率；Mybatis默认定义两级缓存；

- 一级缓存： 默认情况下开启，sqlSession 级别的缓存，也称本地缓存。
- 二级缓存：需要手动配置，他是基于namespace 级别的缓存。
- 为了提高拓展性，Mybatis 定义了缓存接口Cach ，我们可以通过实现Cache接口来定义二级缓存；



### 6.1 缓存的使用

二级缓存使用前提：

- 在全局配置文件中，需要开启允许二级缓存，<setting name="cacheEnabled" value="true"/>
- 在mapper.xml中配置使用二级缓存
- POJO类需要 实现序列化接口；

```xml
<!-- <cache eviction="FIFO" flushInterval="60000" readOnly="false" size="1024"></cache> -->
<!--  
eviction:缓存的回收策略：
	• LRU – 最近最少使用的：移除最长时间不被使用的对象。
	• FIFO – 先进先出：按对象进入缓存的顺序来移除它们。
	• SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。
	• WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。
	• 默认的是 LRU。
flushInterval：缓存刷新间隔
	缓存多长时间清空一次，默认不清空，设置一个毫秒值
readOnly:是否只读：
	true：只读；mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。
			 mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。不安全，速度快
	false：非只读：mybatis觉得获取的数据可能会被修改。
			mybatis会利用序列化&反序列的技术克隆一份新的数据给你。安全，速度慢
size：缓存存放多少元素；
type=""：指定自定义缓存的全类名；
		实现Cache接口即可；
-->
```
```java
/**
 * 两级缓存：
 * 一级缓存：（本地缓存）：sqlSession级别的缓存。一级缓存是一直开启的；SqlSession级别的一个Map
 * 		与数据库同一次会话期间查询到的数据会放在本地缓存中。
 * 		以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库；
 * 
 * 		一级缓存失效情况（没有使用到当前一级缓存的情况，效果就是，还需要再向数据库发出查询）：
 * 		1、sqlSession不同。
 * 		2、sqlSession相同，查询条件不同.(当前一级缓存中还没有这个数据)
 * 		3、sqlSession相同，两次查询之间执行了增删改操作(这次增删改可能对当前数据有影响)
 * 		4、sqlSession相同，手动清除了一级缓存（缓存清空）
 * 
 * 二级缓存：（全局缓存）：基于namespace级别的缓存：一个namespace对应一个二级缓存：
 * 		工作机制：
 * 		1、一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中；
 * 		2、如果会话关闭；一级缓存中的数据会被保存到二级缓存中；新的会话查询信息，就可以参照二级缓存中的内容；
 * 		3、sqlSession===EmployeeMapper==>Employee
 * 						DepartmentMapper===>Department
 * 			不同namespace查出的数据会放在自己对应的缓存中（map）
 * 			效果：数据会从二级缓存中获取
 * 				查出的数据都会被默认先放在一级缓存中。只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中
 * 		使用：
 * 			1）、开启全局二级缓存配置：<setting name="cacheEnabled" value="true"/>
 * 			2）、去mapper.xml中配置使用二级缓存：
 * 				<cache></cache>
 * 			3）、我们的POJO需要实现序列化接口
 * 	
 * 和缓存有关的设置/属性：
 * 			1）、cacheEnabled=true：false：关闭缓存（二级缓存关闭）(一级缓存一直可用的)
 * 			2）、每个select标签都有useCache="true"：
 * 					false：不使用缓存（一级缓存依然使用，二级缓存不使用）
 * 			3）、【每个增删改标签的：flushCache="true"：（一级二级都会清除）】
 * 					增删改执行完成后就会清楚缓存；
 * 					测试：flushCache="true"：一级缓存就清空了；二级也会被清除；
 * 					查询标签：flushCache="false"：
 * 						如果flushCache=true;每次查询之后都会清空缓存；缓存是没有被使用的；
 * 			4）、sqlSession.clearCache();只是清楚当前session的一级缓存；
 * 			5）、localCacheScope：本地缓存作用域：（一级缓存SESSION）；当前会话的所有数据保存在会话缓存中；
 * 								STATEMENT：可以禁用一级缓存；		
 * 				
 *第三方缓存整合：
 *		1）、导入第三方缓存包即可；
 *		2）、导入与第三方缓存整合的适配包；官方有；
 *		3）、mapper.xml中使用自定义缓存
 *		<cache type="org.mybatis.caches.ehcache.EhcacheCache"></cache>
 *
 */
```
### 6.2 缓存机制



![image-20210125144417021](/Users/anner/Library/Application Support/typora-user-images/image-20210125144417021.png)



### 6.3  整合第三方缓存包（Ehcache）

步骤：

- 引入相关依赖

```xml
<!-- mybatis 整合 ehcache -->
<dependency>
     <groupId>org.mybatis.caches</groupId>
     <artifactId>mybatis-ehcache</artifactId>
     <version>1.1.0</version>
</dependency>

<!-- ehcache 相关依赖-->
<dependency>
    <groupId>net.sf.ehcache</groupId>
    <artifactId>ehcache</artifactId>
    <version>2.10.2</version>
</dependency>

<dependency>
    <groupId>net.sf.ehcache</groupId>
    <artifactId>ehcache-core</artifactId>
    <version>2.6.11</version>
</dependency>
<dependency>
    <groupId>net.sf.ehcache</groupId>
    <artifactId>ehcache-web</artifactId>
    <version>2.0.4</version>
</dependency>

<!--        slf4j 日志相关依赖-->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.21</version>
</dependency>
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-log4j12</artifactId>
    <version>1.7.21</version>
</dependency>

```

- Mapper.xml 中使用第三方缓存

```xml
<cache type="org.mybatis.caches.ehcache.EhcacheCache"></cache>
```

- 配置 ehcache.xml 配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:noNamespaceSchemaLocation="../config/ehcache.xsd">
 <!-- 磁盘保存路径 -->
 <diskStore path="D:\44\ehcache" />
 
 <defaultCache 
   maxElementsInMemory="10000" 
   maxElementsOnDisk="10000000"
   eternal="false" 
   overflowToDisk="true" 
   timeToIdleSeconds="120"
   timeToLiveSeconds="120" 
   diskExpiryThreadIntervalSeconds="120"
   memoryStoreEvictionPolicy="LRU">
 </defaultCache>
</ehcache>
 
<!-- 
属性说明：
l diskStore：指定数据在磁盘中的存储位置。
l defaultCache：当借助CacheManager.add("demoCache")创建Cache时，EhCache便会采用<defalutCache/>指定的的管理策略
 
以下属性是必须的：
l maxElementsInMemory - 在内存中缓存的element的最大数目 
l maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大
l eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断
l overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上
 
以下属性是可选的：
l timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大
l timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大
 diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.
l diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。
l diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作
l memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出）
 -->
```



## 七、Mybatis 逆向工程

​	Mybatis Generator 是专门为My吧提升框架定制的代码生成器，可以款素根据表生成对应的映射文件，接口，bean,类，支持根据增删改查，以及QBC风格的条件查询，但是表连接，存储过程等等这些复杂的操作还需手工完成；

**实操：**

1、导入依赖

```xml
<dependency>
      <groupId>org.mybatis.generator</groupId>
      <artifactId>mybatis-generator-core</artifactId>
      <version>1.3.5</version>
</dependency>
```

2、MGB.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>
    <!--加载资源文件-->
    <properties resource="generator.properties"></properties>
    <context id="testTables" targetRuntime="MyBatis3">
        <commentGenerator>
            <!--是否去除自动生成的注释 true是：false 否-->
            <property name="suppressAllComments" value="true"/>
        </commentGenerator>
        <!--数据库连接-->
        <jdbcConnection driverClass="${jdbc.driver}" connectionURL="${jdbc.url}" userId="${jdbc.userId}" password="${jdbc.pwd}"></jdbcConnection>
        <!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL和NUMERIC类型解析为java.math.BigDecimal -->
        <javaTypeResolver>
            <property name="forceBigDecimals" value="false"/>
        </javaTypeResolver>
        <!--targetPackage目标包，生成实体类的位置-->
        <javaModelGenerator targetPackage="com.lwc.entity" targetProject="src/main/java">
            <!--enableSubPackages,是否让schema作为包的后缀-->
            <property name="enableSubPackages" value="false"/>
            <!--从数据库返回的值被清除前后空格-->
            <property name="trimStrings" value="true"/>
        </javaModelGenerator>
        <!--targetProject:mapper映射文件生成的位置-->
        <sqlMapGenerator targetPackage="mapper" targetProject="./src/main/resources">
            <property name="enableSubPackages" value="false"></property>

        </sqlMapGenerator>
        <!--targetPackage:mapper接口生成的位置-->
        <javaClientGenerator type="XMLMAPPER" targetPackage="com.lwc.dao" targetProject="src/main/java">
            <property name="enableSubPackages" value="false"/>
        </javaClientGenerator>
        <!--指定数据库表，要和数据库中进行对应，否则将会出错-->
        <table tableName="student"  domainObjectName="student"
               enableCountByExample="false" enableUpdateByExample="false"
               enableDeleteByExample="false" enableSelectByExample="false"
               selectByExampleQueryId="false"></table>
        <table tableName="t_news"  domainObjectName="tNews"
               enableCountByExample="false" enableUpdateByExample="false"
               enableDeleteByExample="false" enableSelectByExample="false"
               selectByExampleQueryId="false"></table>
    </context>
</generatorConfiguration>
```

3、执行相关

```java
public class GeneratorTest {
    public void testGenerator() throws IOException, XMLParserException, InvalidConfigurationException, SQLException, InterruptedException {
        List<String> warnings=new ArrayList<String>();
        boolean overWriter=true;
　　　　//指向配置文件　　
        File configFile=new File(GeneratorTest.class.getResource("/setting/generatorConfig").getFile());
        ConfigurationParser cp=new ConfigurationParser(warnings);
        Configuration config=cp.parseConfiguration(configFile);
        DefaultShellCallback callback=new DefaultShellCallback(overWriter);
        MyBatisGenerator myBatisGenerator=new MyBatisGenerator(config,callback,warnings);
        myBatisGenerator.generate(null);
    }

    public static void main(String[] args)throws Exception {
        GeneratorTest generatorTest=new GeneratorTest();
        generatorTest.testGenerator();
    }
}
```

## 八、Mybatis 原理

1、根据配置文件创建sqlSessionFactory

![image-20210128165425787](/Users/anner/Library/Application Support/typora-user-images/image-20210128165425787.png)

configuration 封装了所有的配置文件的信息；总结：将所有的配置文件信息解析到configuration中；

2、获取sqlSession 对象

![image-20210128170331054](/Users/anner/Library/Application Support/typora-user-images/image-20210128170331054.png)

返回s q l S e s si on 实现类，DefalutSqlSession对象，DefalutSqlSession包含configuration,以及Exectoer;

3、获取接口的代理对象（MapperProxy）

![image-20210128172026061](/Users/anner/Library/Application Support/typora-user-images/image-20210128172026061.png)

Getmapper*() 方法， getMapper，使用MapperProxyFactory创建一个MapperProxy的代理对象，代理对象里面包含了，DefaultSqlSession（Executor）；

![image-20210128174340944](/Users/anner/Library/Application Support/typora-user-images/image-20210128174340944.png)

```java
/**
	 * 1、获取sqlSessionFactory对象:
	 * 		解析文件的每一个信息保存在Configuration中，返回包含Configuration的DefaultSqlSession；
	 * 		注意：【MappedStatement】：代表一个增删改查的详细信息
	 * 
	 * 2、获取sqlSession对象
	 * 		返回一个DefaultSQlSession对象，包含Executor和Configuration;
	 * 		这一步会创建Executor对象；
	 * 
	 * 3、获取接口的代理对象（MapperProxy）
	 * 		getMapper，使用MapperProxyFactory创建一个MapperProxy的代理对象
	 * 		代理对象里面包含了，DefaultSqlSession（Executor）
	 * 4、执行增删改查方法
	 * 
	 * 总结：
	 * 	1、根据配置文件（全局，sql映射）初始化出Configuration对象
	 * 	2、创建一个DefaultSqlSession对象，
	 * 		他里面包含Configuration以及
	 * 		Executor（根据全局配置文件中的defaultExecutorType创建出对应的Executor）
	 *  3、DefaultSqlSession.getMapper（）：拿到Mapper接口对应的MapperProxy；
	 *  4、MapperProxy里面有（DefaultSqlSession）；
	 *  5、执行增删改查方法：
	 *  		1）、调用DefaultSqlSession的增删改查（Executor）；
	 *  		2）、会创建一个StatementHandler对象。
	 *  			（同时也会创建出ParameterHandler和ResultSetHandler）
	 *  		3）、调用StatementHandler预编译参数以及设置参数值;
	 *  			使用ParameterHandler来给sql设置参数
	 *  		4）、调用StatementHandler的增删改查方法；
	 *  		5）、ResultSetHandler封装结果
	 *  注意：
	 *  	四大对象每个创建的时候都有一个interceptorChain.pluginAll(parameterHandler);
	 * 
	 * @throws IOException
	 */
```

  ## 九、插件

```java
**
	 * 插件原理
	 * 在四大对象创建的时候
	 * 1、每个创建出来的对象不是直接返回的，而是
	 * 		interceptorChain.pluginAll(parameterHandler);
	 * 2、获取到所有的Interceptor（拦截器）（插件需要实现的接口）；
	 * 		调用interceptor.plugin(target);返回target包装后的对象
	 * 3、插件机制，我们可以使用插件为目标对象创建一个代理对象；AOP（面向切面）
	 * 		我们的插件可以为四大对象创建出代理对象；
	 * 		代理对象就可以拦截到四大对象的每一个执行；
	 * 
		public Object pluginAll(Object target) {
		    for (Interceptor interceptor : interceptors) {
		      target = interceptor.plugin(target);
		    }
		    return target;
		  }
		
	 */
```

